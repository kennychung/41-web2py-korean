## The views 뷰
``views``:inxx ``template language``:inxx ``HTML``:inxx

web2py uses Python for its models, controllers, and views, although it uses a slightly modified Python syntax in the views to allow more readable code without imposing any restrictions on proper Python usage.
Web2py는 model, controller, view를 위해서 Python을 이용한다. View에서는 Python사용에 어떤 제약을 주지 않으면서도  코드를 좀 더 읽기 쉽게 만들기 위해서 Python 구문을 약간 수정해서 사용합니다.

The purpose of a view is to embed code (Python) in an HTML document. In general, this poses some problems:
- How should embedded code be escaped?
- Should indenting be based on Python or HTML rules?
View의 목적은 HTML 문서에 Python코드를 내장시키는 것입니다. 일반적으로 이러한 방법은 몇가지 문제를 가지고 있습니다:
- 어떻게 내장한 코드를 코드 변환(escape)할 것인지?
- 들여쓰기는 Python을 기준으로 할것인가? HTML을 기준으로 할 것인가?

web2py uses ``{{ ... }}`` to escape Python code embedded in HTML. The advantage of using curly brackets instead of angle brackets is that it's transparent to all common HTML editors. This allows the developer to use those editors to create web2py views.
Web2py는 HTML안에 내장된 Python 코드를 변환(ecape)하기 위해서 ``{{...}}``를 사용합니다. 대괄호 대신 중괄호를 사용하는 이점은 모든 HTML 편집기에서 동작하는 것입니다. 이렇게 해서 개발자가 HTML 에디터를 이용해서 Web2py view를 생성할 수 있게 해줍니다.

Since the developer is embedding Python code into HTML, the document should be indented according to HTML rules, and not Python rules. Therefore, we allow unindented Python inside the ``{{ ... }}`` tags. Since Python normally uses indentation to delimit blocks of code, we need a different way to delimit them; this is why the web2py template language makes use of the Python keyword ``pass``.
HTML에 Python코드를 내장하기 때문에 문서는 Python규칙이 아닌 HTML 규칙에 맞게 들여쓰기 되어야 합니다. 그래서 ``{{...}}`` 태그안에 Python 코드는 들여쓰기를 하지 않아도 되도록 하였습니다. 보통 Python은 코드 블럭을 구분하기 위해서 들여쓰기를 사용하지만 여기서는 다른 방법이 필요합니다. 그래서 Web2py Template Language에서 Python 예약어인 ``pass``를 사용합니다.

-------
A code block starts with a line ending with a colon and ends with a line beginning with ``pass``. The keyword ``pass`` is not necessary when the end of the block is obvious from the context.
코드 블럭은 콜론(:)으로 끝나는 라인으로 시작하고  ``pass``로 시작하는 라인으로 끝이 납니다. 예약어 ``pass``는 문맥상 명확한 경우에는 필요하지 않습니다.
-------

Here is an example:
예제를 보시죠.

``
{{
if i == 0:
response.write('i is 0')
else:
response.write('i is not 0')
pass
}}
``:code

Note that ``pass`` is a Python keyword, not a web2py keyword. Some Python editors, such as Emacs, use the keyword ``pass`` to signify the division of blocks and use it to re-indent code automatically.
``pass``는 Python 예약어이지 Web2py 예약어가 아님을 주목하세요.  Emacs같은 어떤 Python 편집기에서는 ``pass``를 일정부분의 블럭을 설정하는데 사용하고 자동으로 들여쓰기 하는데 사용합니다.

The web2py template language does exactly the same. When it finds something like:
Web2py Template Lauguage에서도 똑같은 일을 합니다. 다음과 같이 코드를 발견하면

``
<html><body>
{{for x in range(10):}}{{=x}}hello<br />{{pass}}
</body></html>
``:code

it translates it into a program:
다음과 같은 프로그램으로 변환합니다.
``
response.write("""<html><body>""", escape=False)
for x in range(10):
    response.write(x)
    response.write("""hello<br />""", escape=False)
response.write("""</body></html>""", escape=False)
``:code
``response.write`` writes to the ``response.body``.

When there is an error in a web2py view, the error report shows the generated view code, not the actual view as written by the developer. This helps the developer debug the code by highlighting the actual code that is executed (which is something that can be debugged with an HTML editor or the DOM inspector of the browser).
Web2py View에 에러가 있는 경우 에러 레포트는 생성된 View코드를 보여줍니다. 개발자가 작성한 실제 View 코드가 아닙니다. 이렇게 해서 개발자가 실제 실행된 구문 강조된(highlighting) 코드를 통해 디버깅하는데 도움을 줍니다(이 코드는 HTML 편집기나 브라우저의 DOM 검사기를 통해서 디버그할 수 도 있습니다.)

Also note that:
또한
``
{{=x}}
``:code

generates
``response.write``:inxx ``escape``:inxx
``
response.write(x)
``:code

Variables injected into the HTML in this way are escaped by default.
The escaping is ignored if ``x`` is an ``XML`` object, even if escape is set to ``True``.
이런 방법으로 HTML에 삽입된 변수들은 기본으로 HTML 변환(escape)됩니다.
HTML 문자 변환(escape)이 ``True``로 설정되어 있다 하더라도 ``x``가 ``XML``객체인 경우 무시됩니다.

Here is an example that introduces the ``H1`` helper:
``H1`` 헬퍼에 대한 예제를 소개합니다:
``
{{=H1(i)}}
``:code

which is translated to:
이것은 다음과 같이 구문 평가에 따라 번역됩니다:
``
response.write(H1(i))
``:code

upon evaluation, the ``H1`` object and its components are recursively serialized, escaped and written to the response body. The tags generated by ``H1`` and inner HTML are not escaped. This mechanism guarantees that all text --- and only text --- displayed on the web page is always escaped, thus preventing XSS vulnerabilities. At the same time, the code is simple and easy to debug.
``H1``객체와 내부 컴포넌트들은 재귀적으로 직렬화, escape되어 response body에 쓰여집니다. ``H1``에 의해서 생성된 tag들과 inner HTML은 escape 되지 않습니다. 이 메커니즘은 웹페이지에서 모든 텍스트 -- 그리고 텍스트만 --는 항상 escape 됩니다. 그래서 XSS 취약점을 막아줍니다. 동시에 코드는 간단하고 디버깅하기에 쉽습니다.

The method ``response.write(obj, escape=True)`` takes two arguments, the object to be written and whether it has to be escaped (set to ``True`` by default). If ``obj`` has an ``.xml()`` method, it is called and the result written to the response body (the ``escape`` argument is ignored). Otherwise it uses the object's ``__str__`` method to serialize it and, if the escape argument is ``True``, escapes it. All built-in helper objects (``H1`` in the example) are objects that know how to serialize themselves via the ``.xml()`` method.
``reponse.write(obj, escape=True)``는 2개의 인자를 갖습니다. 쓰여질 object와 object가 escape되어질지 여부(기본으로 ``True``로 설정)를 가르킵니다. ``obj``가 ``.xml()`` 메소드를 가지고 있다면 이것은 호출되고 결과값이 reponse body에 쓰여집니다(``escape`` 인자는 무시됩니다). 반면에 ``.xml()``메소드가 없는 경우 직렬화하는데 ``__str__``메소드를  사용하고 escape 인자가 ``True``로 설정되어 있는 경우 escape합니다. 모든 빌트인 Helper 객체들(``H1``같은객체들)은 어떻게 ``.xml()``메소드를 통해서 자신을 직렬화하는지 알고 있습니다.
  
This is all done transparently. You never need to (and never should) call the ``response.write`` method explicitly.
이것은 모두 투명하게 이루어지고 명시적으로 ``response.write``메소드를 호출할 필요가 없습니다(결코 호출해서도 안됩니다).

### Basic syntax 기본 구문

The web2py template language supports all Python control structures. Here we provide some examples of each of them. They can be nested according to usual programming practice.
Web2py 템플릿 언어는 모든 Python 컨트롤 구문을 지원합니다. 여기서는 각각에 대한 예제를 제공합니다. 이것들은 일반적인 프로그래밍 관행대로 포함될 수 있습니다.

#### ``for...in``
``for``:inxx

In templates you can loop over any iterable object:
템플릿 안에서 순회가능한 어떤 객체에 대해서도 순회가능합니다:
``
{{items = ['a', 'b', 'c']}}
<ul>
{{for item in items:}}<li>{{=item}}</li>{{pass}}
</ul>
``:code

which produces:
다음을 생성합니다:
``
<ul>
<li>a</li>
<li>b</li>
<li>c</li>
</ul>
``:code

Here ``item`` is any iterable object such as a Python list, Python tuple, or Rows object, or any object that is implemented as an iterator. The elements displayed are first serialized and escaped.
여기서 ``item``은  Python list, tuple, Row 객체들처럼 또는 순회자로 구현된 객체입니다. 표시되는 요소들은 먼저 직렬화되고 escape됩니다.

#### ``while``
``while``:inxx

You can create a loop using the while keyword:
while 키워드를 이용해서 루프를 생성할 수 있습니다:
``
{{k = 3}}
<ul>
{{while k > 0:}}<li>{{=k}}{{k = k - 1}}</li>{{pass}}
</ul>
``:code

which produces:
다음과 같이 생성합니다:
``
<ul>
<li>3</li>
<li>2</li>
<li>1</li>
</ul>
``:code

#### ``if...elif...else``
``if``:inxx ``elif``:inxx ``else``:inxx

You can use conditional clauses:
조건절을 이용할수도있습니다:
``
{{
import random
k = random.randint(0, 100)
}}
<h2>
{{=k}}
{{if k % 2:}}is odd{{else:}}is even{{pass}}
</h2>
``:code

which produces:
다음과 같이 생성합니다:
``
<h2>
45 is odd
</h2>
``:code

Since it is obvious that ``else`` closes the first ``if`` block, there is no need for a ``pass`` statement, and using one would be incorrect. However, you must explicitly close the ``else`` block with a ``pass``.
``else``는 첫번째 ``if`` block을 닫는것은 명확하기 때문에 ``pass`` 구문을 사용할 필요가 없으며 ``pass``를 사용하는것은 맞지 않습니다. 그러나 ``else``블럭은 명시적으로 ``pass``로 닫아야 합니다.

Recall that in Python "else if" is written ``elif`` as in the following example:
Python에서 "else if"가 ``elif``로 쓰여진다는 것을 상기하며 다음을 살펴봅시다.:

``
{{
import random
k = random.randint(0, 100)
}}
<h2>
{{=k}}
{{if k % 4 == 0:}}is divisible by 4
{{elif k % 2 == 0:}}is even
{{else:}}is odd
{{pass}}
</h2>
``:code

It produces:
다음을 생성합니다:
``
<h2>
64 is divisible by 4
</h2>
``:code

#### ``try...except...else...finally``
``try``:inxx ``except``:inxx ``else``:inxx ``finally``:inxx

It is also possible to use ``try...except`` statements in views with one caveat. Consider the following example:
뷰에서 ``try...except``절을 사용할수 있지만 한가지 주의할 점이 있습니다. 다음 예제를 살펴봅시다:
``
{{try:}}
Hello {{= 1 / 0}}
{{except:}}
division by zero
{{else:}}
no division by zero
{{finally}}
<br />
{{pass}}
``:code

It will produce the following output:
다음과 같이 출력합니다:
``
Hello
division by zero
<br />
``:code

This example illustrates that all output generated before an exception occurs is rendered (including output that preceded the exception) inside the try block. "Hello" is written because it precedes the exception.
이 예제는 try 블럭 안에서 예외가 발생하기전에 생성된 출력은 표시된다는 것을 나타냅니다.
"Hello"는 예외 이전에 처리되었기 때문에 출력되었습니다.

#### ``def...return``
``def``:inxx ``return``:inxx

The web2py template language allows the developer to define and implement functions that can return any Python object or a text/html string. Here we consider two examples:
Web2py템플린 언어는 개발자가 Python객체 또는 text/html문자열을 리턴하는 어떤 함수들이라도 정의하고 구현할수 있게 해줍니다. 다음 2예제를 살펴봅시다:
``
{{def itemize1(link): return LI(A(link, _href="http://" + link))}}
<ul>
{{=itemize1('www.google.com')}}
</ul>
``:code

produces the following output:
다음을 출력합니다.
``
<ul>
<li><a href="http:/www.google.com">www.google.com</a></li>
</ul>
``:code

The function ``itemize1`` returns a helper object that is inserted at the location where the function is called.
함수 ``itemize1``은 helper object를 리턴하고 이 helper 객체는 함수가 호출된 위치에 삽입됩니다.

Consider now the following code:
이제 다음 예제를 살펴봅시다:
``
{{def itemize2(link):}}
<li><a href="http://{{=link}}">{{=link}}</a></li>
{{return}}
<ul>
{{itemize2('www.google.com')}}
</ul>
``:code

It produces exactly the same output as above. In this case, the function ``itemize2`` represents a piece of HTML that is going to replace the web2py tag where the function is called. Notice that there is no '=' in front of the call to ``itemize2``, since the function does not return the text, but it writes it directly into the response.
이 함수는 이전과 정확히 동일한 출력을 생성합니다. 이경우 함수 ``itemize2``는 약간의 HTML를 나타내고 이것은 함수가 호출된 web2py 태그와 교체될 것입니다. ``itemize2`` 호출 앞에 '='가 없다는 것에 주목하세요. 함수가 텍스트를 리턴하지않고 곧바로 response에 쓰기 때문입니다. 

There is one caveat: functions defined inside a view must terminate with a return statement, or the automatic indentation will fail.
여기에는 한가지 주의할 점이 있습니다: 뷰 내부에 정의된 함수들은 return 문으로 끝나야 한다는 것입니다. 아니면 자동 들여쓰기는 실패하게될것입니다.

### HTML helpers
``helpers``:inxx

Consider the following code in a view:
뷰안에 다음과 같은 코드가 있다고 합시다:
``
{{=DIV('this', 'is', 'a', 'test', _id='123', _class='myclass')}}
``:code

it is rendered as:
다음과 같이 표시되고:
``
<div id="123" class="myclass">thisisatest</div>
``:code
``DIV`` is a helper class, i.e., something that can be used to build HTML programmatically. It corresponds to the HTML ``<div>`` tag.
``DIV``는  helper 클래스입니다. 예를 들어 HTML을 프로그래밍적으로 만드는데 사용될 수 있습니다. 이것은 HTML ``<div>``태그에 해당합니다.

Positional arguments are interpreted as objects contained between the open and close tags. Named arguments that start with an underscore are interpreted as HTML tag attributes (without the underscore). Some helpers also have named arguments that do not start with underscore; these arguments are tag-specific.
위치기반 인자들은 open과 close태그 사잉 객체로 해석됩니다. _(underscore)로 시작하는 명명된 인자들은 HTML 태그의 속성(_없는 속성)으로 해석됩니다. 어떤 헬퍼들은 또한 underscore로 시작하지 않는 명명된 인자로 시작합니다. 이 인자들은 태그에 종속적입니다. 

Instead of a set of unnamed arguments, a helper can also take a single list or tuple as its set of components using the ``*`` notation and it can take a single dictionary as its set of attributes using the ``**``, for example:
 헬퍼는 명명되지 않은 인자 셋 대신에 ``*``표시를 이용해서 하나의 리스트나 튜플로 취할수 있으며 ``**``를 이용해서 하나의 사전으로도 인자를 취할 수 있습니다. 예를 들어:

``
{{
contents = ['this','is','a','test']
attributes = {'_id':'123', '_class':'myclass'}
=DIV(*contents,**attributes)
}}
``:code
(produces the same output as before).
(이전과 같은 출력을 생성합니다.)

The following set of helpers:
다음의 헬퍼들은 

``A``,  ``B``,  ``BEAUTIFY``,  ``BODY``,  ``BR``,  ``CAT``,  ``CENTER``,  ``CODE``,  ``COL``, ``COLGROUP``, ``DIV``,  ``EM``,  ``EMBED``,  ``FIELDSET``,  ``FORM``,  ``H1``,  ``H2``,  ``H3``,  ``H4``,  ``H5``,  ``H6``,  ``HEAD``,  ``HR``,  ``HTML``,  ``I``,  ``IFRAME``,  ``IMG``,  ``INPUT``,  ``LABEL``,  ``LEGEND``,  ``LI``,  ``LINK``,  ``MARKMIN``,  ``MENU``,  ``META``,  ``OBJECT``,  ``ON``,  ``OL``,  ``OPTGROUP``,  ``OPTION``,  ``P``,  ``PRE``,  ``SCRIPT``,  ``SELECT``,  ``SPAN``,  ``STYLE``,  ``TABLE``,  ``TAG``,  ``TBODY``,  ``TD``,  ``TEXTAREA``,  ``TFOOT``,  ``TH``,  ``THEAD``,  ``TITLE``,  ``TR``,  ``TT``, ``UL``,   ``URL``,  ``XHTML``,  ``XML``,  ``embed64``,  ``xmlescape``

can be used to build complex expressions that can then be serialized to XML``xml:w``:cite ``xml:o``:cite. For example:
복잡한 식을 만드는데 사용될 수 있으며 이것은 XML``xml:w``:cite ``xml:o``:cite로 직렬화 될 수 있습니다. 예들 들면:
``
{{=DIV(B(I("hello ", "<world>"))), _class="myclass")}}
``:code

is rendered:
다음과 같이 표시됩니다:

``
<div class="myclass"><b><i>hello &lt;world&gt;</i></b></div>
``:code

Helpers can also be serialized into strings, equivalently, with the ``__str__`` and the ``xml`` methods:
도움 객체들은 ``__str__``과 ``xml``메소드로 동일하게 문자열로 직렬화 될 수 있습니다:

``
>>> print str(DIV("hello world"))
<div>hello world</div>
>>> print DIV("hello world").xml()
<div>hello world</div>
``

``Document Object Model (DOM)``:inxx
The helpers mechanism in web2py is more than a system to generate HTML without concatenating strings. It provides a server-side representation of the Document Object Model (DOM).
Web2py에서 헬퍼의 메커니즘은 문자열을 합치는 기는이 없는 HTML을 생성하는 시스템 이상입니다. DOM이 서버측 표현을 제공합니다.

Components of helpers can be referenced via their position, and helpers act as lists with respect to their components:
헬퍼의 컴포넌드들은 그들의 위치로 참조될수 있고 그들의 컴포넌트들에 따라서 리스트처럼 행동합니다:
``
>>> a = DIV(SPAN('a', 'b'), 'c')
>>> print a
<div><span>ab</span>c</div>
>>> del a[1]
>>> a.append(B('x'))
>>> a[0][0] = 'y'
>>> print a
<div><span>yb</span><b>x</b></div>
``:code

Attributes of helpers can be referenced by name, and helpers act as dictionaries with respect to their attributes:
헬퍼의 속성들은 이름으로 참조될수 있으며 그들 속성을 고려하여 사전처럼 행동합니다.
``
>>> a = DIV(SPAN('a', 'b'), 'c')
>>> a['_class'] = 's'
>>> a[0]['_class'] = 't'
>>> print a
<div class="s"><span class="t">ab</span>c</div>
``:code

Note, the complete set of components can be accessed via a list called ``a.components``, and the complete set of attributes can be accessed via a dictionary called ``a.attributes``. So, ``a[i]`` is equivalent to ``a.components[i]`` when ``i`` is an integer, and ``a[s]`` is equivalent to ``a.attributes[s]`` when ``s`` is a string.
컴포넌트의 전체셋은 ``a.components``로 불리우는 리스트를 통해서 접근가능하며 속성의 전체 셋은 ``a.attributes``라는 사전을 통해서 접근가능합니다. 그래서 ``a[i]``는 i가 integer인 경우 ``a.components[i]``와 동일하며 ``a[s]``는 ``s``가 문자열인경우 ``a.attributes[s]``와 동일합니다.

Notice that helper attributes are passed as keyword arguments to the helper. In some cases, however, attribute names include special characters that are not allowed in Python identifiers (e.g., hyphens) and therefore cannot be used as keyword argument names. For example:
도움 속성들은 헬퍼에 예약어 인자로 전달된다는 것에 주의하세요. 그러나 어떤 경우에는 속성의 이름이 Python 식별자에서는 허용되지 않는 특수문자를 포함하고 있어(예를 들어 '-'hiphen) 그래서 예약어 인자 이름으로 사용될 수 없습니다. 예들 들면:

``
DIV('text', _data-role='collapsible')
``:code

will not work because "_data-role" includes a hyphen, which will produce a Python syntax error.
위 구문은 동작하지 않습니다. 왜냐하면 "_data-role"은 -(hyphen)을 포함하고 있고 이것은 Python 구문 오류를 발생시킵니다.

In such cases, you can instead pass the attributes as a dictionary and make use of Python's ``**`` function arguments notation, which map a dictionary of (key:value) pairs into a set of keyword arguments:
이 경우 속성을 사전으로 전달 할 수 있습니다. 사전은 python 의 ``**`` 함수 인자 표시법을 이용합니다. ``**``는 (key:value) 페어의 사전을 예약어 인자 셋으로 매핑합니다.

``
>>> print DIV('text', **{'_data-role': 'collapsible'})
<div data-role="collapsible">text</div>
``:code

You can also dynamically create special TAGs:
또한 동적으로 특별한 TAG를 생성할 수 있습니다:
``
>>> print TAG['soap:Body']('whatever',**{'_xmlns:m':'http://www.example.org'})
<soap:Body xmlns:m="http://www.example.org">whatever</soap:Body>
``:code

#### ``XML``
``XML``:inxx
``XML`` is an object used to encapsulate text that should not be escaped. The text may or may not contain valid XML. For example, it could contain JavaScript.
``XML``은 escape되지 않아야 하는 텍스트를 캡슐화하는데 사용되는 객체입니다. 텍스트는 유효한 XML을 포함하고 있을 있을수도 있고 아닐 수도 있습니다. 예들 들어 이것은 JavaScript를 포함할 수도 있습니다. 

The text in this example is escaped:
이 예제의 텍스트는 escape됩니다:
``
>>> print DIV("<b>hello</b>")
&lt;b&gt;hello&lt;/b&gt;
``:code

by using ``XML`` you can prevent escaping:
``XML``을 사용해서 escape를 막을수 있습니다:
``
>>> print DIV(XML("<b>hello</b>"))
<b>hello</b>
``:code

Sometimes you want to render HTML stored in a variable, but the HTML may contain unsafe tags such as scripts:
때로는 변수에 저장되어 있는 HTML를 표시하기를 윈하지만 HTML에는 다음과 같은 안전하지 않는 script가 포함되어 있을 수 있습니다:
``
>>> print XML('<script>alert("unsafe!")</script>')
<script>alert("unsafe!")</script>
``:code

Un-escaped executable input such as this (for example, entered in the body of a comment in a blog) is unsafe, because it can be used to generate Cross Site Scripting (XSS) attacks against other visitors to the page.
위와 같은 escape되지 않은 실행가능한 입력은(예를 들어 blog에서 코멘트 바디에 포함되어 입력된 경우) 안전하지 않습니다. 왜냐하면 Cross Site Scription(XSS)를 생성하는데 사용될 수 있고 페이지를 방문하는 다른 사용자를 공격하는데 사용될 수 있기 때문입니다. 

``sanitize``:inxx
The web2py ``XML`` helper can sanitize our text to prevent injections and escape all tags except those that you explicitly allow. Here is an example:
Web2py의 ``XML`` 헬퍼는 삽입(injection)을 막기 위해 우리의 텍스트를 무효화(sanitize)할 수 있으며 명시적으로 지정한 태그를 제외하고 모든 태그들을 escape할 수 있습니다.
 sanitize
``
>>> print XML('<script>alert("unsafe!")</script>', sanitize=True)
&lt;script&gt;alert(&quot;unsafe!&quot;)&lt;/script&gt;
``:code

The ``XML`` constructors, by default, consider the content of some tags and some of their attributes safe. You can override the defaults using the optional ``permitted_tags`` and ``allowed_attributes`` arguments. Here are the default values of the optional arguments of the ``XML`` helper.
기본으로 ``XML`` 생성자들은 몇몇 태그들의 내용과 몇개의 속성을 안전하다고 여깁니다. 선택적인 ``permitted_tags``와 ``allowed_attributes`` 인자를 이용해서 기본값을 변경할 수 있습니다. 다음은 ``XML``헬퍼의 선택적인 인자의 기본값입니다. 
``
XML(text, sanitize=False,
    permitted_tags=['a', 'b', 'blockquote', 'br/', 'i', 'li',
       'ol', 'ul', 'p', 'cite', 'code', 'pre', 'img/'],
    allowed_attributes={'a':['href', 'title'],
       'img':['src', 'alt'], 'blockquote':['type']})
``:code

#### Built-in helpers

##### ``A``

This helper is used to build links.
이 헬퍼는 링크를 만드는데 사용됩니다.

``A``:inxx
``
>>> print A('<click>', XML('<b>me</b>'),
            _href='http://www.web2py.com')
<a href='http://www.web2py.com'>&lt;click&gt;<b>me/b></a>
``:code

Instead of ``_href`` you can pass the URL using the ``callback`` argument. For example in a view:
``_href``대신에 ``callback``인자를 이용해서 URL을 전달할 수 있습니다. 뷰에서 예들 들면:

``
{{=A('click me', callback=URL('myaction'))}}
``

and the effect of pressing the link will be an ajax call to "myaction" instead of a redirection.
In this case, optionally you can specify two more arguments: ``target`` and ``delete``:
링크를 누르면 redirection대신에 "myaction"을 ajax 호출될 것입니다. 이 경우, 선택적으로 2개의 인자를 추가로 지정할 수 있습니다: ``target``과 ``delete``: 
``
{{=A('click me', callback=URL('myaction'), target="t")}}
<div id="t"><div>
``
and the response of the ajax callback will be stored in the DIV with id equal to "t".
ajax callback의 응답은 id가 "t"인  DIV에 저장될 것입니다.

``
<div id="b">{{=A('click me', callback=URL('myaction'), delete='div#b")}}</div>
``
and upon response, the closest tag matching "div#b" will be deleted. In this case, the button will be deleted.
A typical application is:
응답에 따라서 "div#b"와 가장 근사한 태그가 삭제될 것입니다. 이 경우 버튼이 삭제 될 것입니다. 통상적인 어플리케이션은 테이블 안에 다음과 같습니다:

``
{{=A('click me', callback=URL('myaction'), delete='tr")}}
``

in a table. Pressing the button will perform the callback and delete the table row.
버튼을 누르면 콜백이 호출되고 테이블의 행을 삭제 할 것입니다.


The A helper takes a special argument called ``cid``. It works as follows:
A 헬퍼는 ``cid``라는 특별한 인자를 갖습니다. 이것은 다음과 같이 동작합니다:

``
``callback`` and ``delete`` can be combined.
``callback``과 ``delete``는 결합될 수 있습니다.
{{=A('linked page', _href='http://example.com', cid='myid')}}
<div id="myid"></div>
``:code

and a click on the link causes the content to be loaded in the div. This is similar but more powerful than the above syntax since it is designed to refresh page components. We discuss applications of ``cid`` in more detail in Chapter 12, in the context of components.
링크를 클릭하면 div안에 컨텐트가 로드된다. 이 방법이 이전 구문과 비슷하지만 더 강력하다 왜나햐면 페이지의 컴포넌트를 갱신하도록 디자인되었기 때문이다. 12장에서 컴포넌트 문맥안에서 ``cid`` 어플리케이션에 대해서 더 자세히 살펴볼 것이다.  

These ajax features require jQuery and "static/js/web2py_ajax.js", which are automatically included by placing ``{{include 'web2py_ajax.html'}}`` in the layout head. "views/web2py_ajax.html" defines some variables based on ``request`` and includes all necessary js and css files.
이 ajax 기능은 jQuery와 "static/js/web2py_ajax.js"가 필요하다. 이것들은 레이아웃의 헤드에  ``{{include 'web2py_ajax.html'}}``을 위치시키면 자동으로 포함된다. "views/web2py_ajax.html"은 ``request``를 기반으로 몇가지 변수들을 정의하고 필요한 모든 js, css파일들을 포함합니다. 

##### ``B``
``B``:inxx

This helper makes its contents bold.
이 헬퍼는 이 객체의 내부 컨텐트를 진하게 표시합니다.
``
>>> print B('<hello>', XML('<i>world</i>'), _class='test', _id=0)
<b id="0" class="test">&lt;hello&gt;<i>world</i></b>
``:code

##### ``BODY``
``BODY``:inxx
This helper makes the body of a page.
페이지의 바디를 만듭니다.
``
>>> print BODY('<hello>', XML('<b>world</b>'), _bgcolor='red')
<body bgcolor="red">&lt;hello&gt;<b>world</b></body>
``:code

##### ``BR``
``BR``:inxx

This helper creates a line break.
개행을 생성합니다.
``
>>> print BR()
<br />
``:code

##### ``CAT`` (1.98.1 and up)
``CAT``:inxx

This helper concatenates other helpers, same as TAG[''].
다른 헬퍼를 연결합니다. TAG['']와 동일.
``
>>> print CAT('Here is a ', A('link',_href=URL()), ', and here is some ', B('bold text'), '.')
Here is a <a href="/app/default/index">link</a>, and here is some <b>bold text</b>.
``:code

##### ``CENTER``
``CENTER``:inxx

This helper centers its content.
컨텐트를 중아에 위치시킵니다.
``
>>> print CENTER('<hello>', XML('<b>world</b>'),
>>>              _class='test', _id=0)
<center id="0" class="test">&lt;hello&gt;<b>world</b></center>
``:code

##### ``CODE``
``CODE``:inxx

This helper performs syntax highlighting for Python, C, C++, HTML and web2py code, and is preferable to ``PRE`` for code listings. ``CODE`` also has the ability to create links to the web2py API documentation.
이 헬퍼는 Python, C, C++, HTML, Web2py code를 위한 구문 강조를 수행하고 코드 표시를 위해서는 ``PRE``를 선호한다. ``CODE`` 는 Web2py API 문서에 대한 링크를 생성할수 있습니다.

Here is an example of highlighting sections of Python code.
다음은 Python code를 강조하는 섹션에 대한 예제입니다.
``
>>> print CODE('print "hello"', language='python').xml()
<table><tr valign="top"><td style="width:40px; text-align: right;"><pre style="
        font-size: 11px;
        font-family: Bitstream Vera Sans Mono,monospace;
        background-color: transparent;
            margin: 0;
            padding: 5px;
            border: none;
        background-color: #E0E0E0;
        color: #A0A0A0;
    ">1.</pre></td><td><pre style="
        font-size: 11px;
        font-family: Bitstream Vera Sans Mono,monospace;
        background-color: transparent;
            margin: 0;
            padding: 5px;
            border: none;
            overflow: auto;
    "><span style="color:#185369; font-weight: bold">print </span>
    <span style="color: #FF9966">"hello"</span></pre></td></tr>
</table>
``:code

Here is a similar example for HTML
다음은 HTML을 위한 비슷한 예제이다.
``
>>> print CODE(
>>>   '<html><body>{{=request.env.remote_add}}</body></html>',
>>>   language='html')
``:code
``
<table>...<code>...
<html><body>{{=request.env.remote_add}}</body></html>
...</code>...</table>
``:code

These are the default arguments for the ``CODE`` helper:
다음은 ``CODE``를 위한 기본 인자들이다.
``
CODE("print 'hello world'", language='python', link=None, counter=1, styles={})
``:code

Supported values for the ``language`` argument are "python", "html_plain", "c", "cpp", "web2py", and "html". The "html" language interprets {{ and }} tags as "web2py" code, while "html_plain" doesn't.
``language``인자에서 지원하는 값들은 "python", "html_plain", "c", "cpp", "web2py", "html"등이 있다. "html" 언어는 {{와}} 태그를 "web2py"코드로 번역하는가 반면에 "html_plain"은 변환하지 않는다. 

If a ``link`` value is specified, for example "/examples/global/vars/", web2py API references in the code are linked to documentation at the link URL. For example "request" would be linked to "/examples/global/vars/request". In the above example, the link URL is handled by the "vars" action in the "global.py" controller that is distributed as part of the web2py "examples" application.
``link``값이 지정되어 있으면(예를들어 "/examples/global/vars/") 코드상의 Web2py API 레퍼런스들은  link URL의 문서를 링크한다. 예를 들어 "request"는 "/examples/global/vars/request"를 링크할 것입니다. 위의 예제에서 link URL은 "global.py" 컨트롤러의 "vars" action에 의해서 처리되고 web2py "examples" 어플리케이션에 포함되어 배포됩니다.

The ``counter`` argument is used for line numbering. It can be set to any of three different values. It can be ``None`` for no line numbers, a numerical value specifying the start number, or a string. If the counter is set to a string, it is interpreted as a prompt, and there are no line numbers.
``counter``인자는 줄번호를 위해서 사용됩니다. 이것은 3가지 다른 값으로 설정될수 있습니다. ``None``은 줄번호가 없는 경우, 시작하는 숫자를 지정하는 숫자값, 또는 문자열이다. counter가 문자열로 설정된 경우 프롬프트로 해석되고 줄번호가 없다. 

The ``styles`` argument is a bit tricky. If you look at the generated HTML above, it contains a table with two columns, and each column has its own style declared inline using CSS. The ``styles`` attributes allows you to override those two CSS styles. For example:
``styles``인자는 약간 까다롭다. 위에 생성된 HTML을 살펴보면, 2개의 컬럼을 갖는 테이블이 포함되어 있습니다.  각 컬럼은 CSS를 이용해서 inline에 선언된 자신의 스타일을 가지고 있습니다. ``style``속성은 이 두개의 CSS Style을 덮어쓸수 있게 해줍니다. 예들 들면: 

``
{{=CODE(...,styles={'CODE':'margin: 0;padding: 5px;border: none;'})}}
``:code

The ``styles`` attribute must be a dictionary, and it allows two possible keys: ``CODE`` for the style of the actual code, and ``LINENUMBERS`` for the style of the left column, which contains the line numbers. Mind that these styles completely replace the default styles and are not simply added to them.
``styles`` 속성은 사전이어야 합니다. 그리고 2개의 키만 가능합니다. ``CODE``는 실제 코드를 위한  style이고 ``LINENUMBERS``는 외쪽 컬럼을 위한 style이고 이것은 줄번호를 포함하고 있습니다.  이들 스타일들은 완전히 기본 스타일을 교체하는 것이지 추가되는 것이 아님을 명심하세요.

##### ``COL``
``COL``:inxx

``
>>> print COL('a','b')
<col>ab</col>
``:code

##### ``COLGROUP``
``COLGROUP``:inxx

``
>>> print COLGROUP('a','b')
<colgroup>ab</colgroup>
``:code

##### ``DIV``
All helpers apart from ``XML`` are derived from ``DIV`` and inherit its basic methods.
``XML``을 제외한 모든 헬퍼들은 ``DIV``로 부터 유도되었고 기본 메소드들을 상속합니다.

``DIV``:inxx
``
>>> print DIV('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<div id="0" class="test">&lt;hello&gt;<b>world</b></div>
``:code

##### ``EM``

Emphasizes its content.
컨텐트를 강조합니다.

``EM``:inxx
``
>>> print EM('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<em id="0" class="test">&lt;hello&gt;<b>world</b></em>
``:code

##### ``FIELDSET``
``FIELDSET``:inxx

This is used to create an input field together with its label.
레이블을 갖는 입력 필드를 생성하는데 사용됩니다.
``
>>> print FIELDSET('Height:', INPUT(_name='height'), _class='test')
<fieldset class="test">Height:<input name="height" /></fieldset>
``:code

##### ``FORM``
``FORM``:inxx

This is one of the most important helpers. In its simple form, it just makes a ``<form>...</form>`` tag, but because helpers are objects and have knowledge of what they contain, they can process submitted forms (for example, perform validation of the fields). This will be discussed in detail in Chapter 7.
이것은 가장 중요한 헬퍼중에 하나입니다. 이 간단한 폼에서 ``<form>...</form>`` 태그를 만들고, 하지만 헬퍼들은 객체들이고 무엇을 포함하고 있는지 알고 있기 때문에 제출된 폼들을 처리할 수 있습니다.( 예를 들어 필드에 대한 유효성검사를 수행한다던지) 이것은 7장에서 자세히 다루어질 예정입니다.
``
>>> print FORM(INPUT(_type='submit'), _action='', _method='post')
<form enctype="multipart/form-data" action="" method="post">
<input type="submit" /></form>
``:code

The "enctype" is "multipart/form-data" by default.
"enctype"은 기본적으로 "multipart/form-data"입니다.

``hidden``:inxx
The constructor of a ``FORM``, and of ``SQLFORM``, can also take a special argument called ``hidden``. When a dictionary is passed as ``hidden``, its items are translated into "hidden" INPUT fields. For example:
``FORM``과 ``SQLFORM``의 생성자는 ``hidden``이라는 특수인자를 취할 수 있습니다. 사전객체가 ``hidden``으로 전달되는 경우 이 아이템들은 "hidden" INPUT 필드로 변역됩니다. 예들들면:

``
>>> print FORM(hidden=dict(a='b'))
<form enctype="multipart/form-data" action="" method="post">
<input value="b" type="hidden" name="a" /></form>
``:code

##### ``H1``, ``H2``, ``H3``, ``H4``, ``H5``, ``H6``
``H1``:inxx

These helpers are for paragraph headings and subheadings:
이들 헬퍼들은 문단의 제목과 부제목을 위한 것입니다:
``
>>> print H1('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<h1 id="0" class="test">&lt;hello&gt;<b>world</b></h1>
``:code

##### ``HEAD``
 
For tagging the HEAD of an HTML page.
HTML 페이지의 HEAD 태그를 나타냅니다. 
``HEAD``:inxx
``
>>> print HEAD(TITLE('<hello>', XML('<b>world</b>')))
<head><title>&lt;hello&gt;<b>world</b></title></head>
``:code

##### ``HTML``
``HTML``:inxx ``XHTML``:inxx

This helper is a little different. In addition to making the ``<html>`` tags,
it prepends the tag with a doctype string``xhtml:w,xhtml:o,xhtml:school``:cite .
이 헬퍼는 조금 다릅니다. ``<html>``태그를 만들뿐만 아니라 doctype string``xhtml:w,xhtml:o,xhtml:scrool``:cite 을 앞에 덧붙입니다.
``
>>> print HTML(BODY('<hello>', XML('<b>world</b>')))
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/html4/loose.dtd">
<html><body>&lt;hello&gt;<b>world</b></body></html>
``:code

The HTML helper also takes some additional optional arguments that have the following default:
HTML 헬퍼는 몇개의 추가적인 선택 인자를 갖으며 다음과 같은 기본값을 갖습니다:
``
HTML(..., lang='en', doctype='transitional')
``:code

where doctype can be 'strict', 'transitional', 'frameset', 'html5', or a full doctype string.
doctype은 'strict', 'transitional', 'frameset', 'html5' 또는 전체 doctype string을 갖을 수 있습니다.

##### ``XHTML``
``XHTML``:inxx

XHTML is similar to HTML but it creates an XHTML doctype instead.
XHTML은 HTML과 비슷하지만 XHTML doctype을 생성합니다.

``
XHTML(..., lang='en', doctype='transitional', xmlns='http://www.w3.org/1999/xhtml')
``:code

where doctype can be 'strict', 'transitional', 'frameset', or a full doctype string.
doctype은 'strict', 'transitional', 'frameset'또는 전체 doctype string을 갖을 수 있습니다.

##### ``HR``
``HR``:inxx

This helper creates a horizontal line in an HTML page
이 도움 객체는 HTML페이지에 수평선을 생성합니다.
``
>>> print HR()
<hr />
``:code

##### ``I``
``I``:inxx

This helper makes its contents italic.
이 도움 객체는 컨텐트를 이텔릭체로 만듭니다.
``
>>> print I('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<i id="0" class="test">&lt;hello&gt;<b>world</b></i>
``:code

##### ``INPUT``
``INPUT``:inxx

Creates an ``<input.../>`` tag. An input tag may not contain other tags, and is closed by ``/>`` instead of ``>``. The input tag has an optional attribute ``_type`` that can be set to "text" (the default), "submit", "checkbox", or "radio".
``<input.../>``태그를 생성합니다. Input 태그는 다른 태그를 포함하지 않으며 ``>``대신에 ``/>``로 끝마칩니다. Input 태그는 선택적인 속성인 ``_type`` 을 갖으며 "text"(기본값), "submit", "checkbox", "radio"의 값으로 설정될 수 있습니다.
``
>>> print INPUT(_name='test', _value='a')
<input value="a" name="test" />
``:code

It also takes an optional special argument called "value", distinct from "_value". The latter sets the default value for the input field; the former sets its current value. For an input of type "text", the former overrides the latter:
또한 "_value"와 구분되는 "value"라는 선택적인 특수 인자를 갖습니다. "_value"는 Input필드의 기본값을 설정하고 "value"는 현재 값을 설정합니다. "text"타입의 Input은 "value"가 "_value"값을 덮어씁니다: 
``
>>> print INPUT(_name='test', _value='a', value='b')
<input value="b" name="test" />
``:code

For radio buttons, ``INPUT`` selectively sets the "checked" attribute:
라디오 버튼의 경우 ``INPUT``은 선택적으로 "checked" 속성을 설정합니다:

``radio``:inxx
``
>>> for v in ['a', 'b', 'c']:
>>>     print INPUT(_type='radio', _name='test', _value=v, value='b'), v
<input value="a" type="radio" name="test" /> a
<input value="b" type="radio" checked="checked" name="test" /> b
<input value="c" type="radio" name="test" /> c
``:code

and similarly for checkboxes:
체크박스를 위해서도 비슷합니다: 

``checkbox``:inxx
``
>>> print INPUT(_type='checkbox', _name='test', _value='a', value=True)
<input value="a" type="checkbox" checked="checked" name="test" />
>>> print INPUT(_type='checkbox', _name='test', _value='a', value=False)
<input value="a" type="checkbox" name="test" />
``:code

##### ``IFRAME``

This helper includes another web page in the current page. The url of the other page is specified via the "_src" attribute.
이 헬퍼는 현재 페이지 안에 다른 페이즈를 포함합니다. 다른 페이지의 URL은 "_src"속성에 지정됩니다.ㄴ

``IFRAME``:inxx
``
>>> print IFRAME(_src='http://www.web2py.com')
<iframe src="http://www.web2py.com"></iframe>
``:code

##### ``IMG``
``IMG``:inxx

It can be used to embed images into HTML:
HTML에 image를 포함시킬때 사용될 수 있습니다:
``
>>> IMG(_src='http://example.com/image.png',_alt='test')
<img src="http://example.com/image.ong" alt="rest" />
``:code

Here is a combination of A, IMG, and URL helpers for including a static image with a link:
다음은 링크를 갖는 고정이미지를 포함시키기 위한 A, IMG, URL 도움 객체의 조합입니다: 

``
>>> A(IMG(_src=URL('static','logo.png'), _alt="My Logo"),
      _href=URL('default','index'))
<a href="/myapp/default/index">
  <img src="/myapp/static/logo.png" alt="My Logo" />
</a>
``:code

##### ``LABEL``

It is used to create a LABEL tag for an INPUT field.
INPUT필드를 위한 LABEL 태그를 생성하는데 사용됩니다.
``LABEL``:inxx
``
>>> print LABEL('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<label id="0" class="test">&lt;hello&gt;<b>world</b></label>
``:code

##### ``LEGEND``

It is used to create a legend tag for a field in a form.
폼안에 필드에 대한 일러두기 태그를 생성하는데 사용된다.

``LEGEND``:inxx
``
>>> print LEGEND('Name', _for='myfield')
<legend for="myfield">Name</legend>
``:code

##### ``LI``

It makes a list item and should be contained in a ``UL`` or ``OL`` tag.
``UL``, ``OL``태그에 포함되는 리스트 아이템을 만듭니다.

``LI``:inxx
``
>>> print LI('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<li id="0" class="test">&lt;hello&gt;<b>world</b></li>
``:code

##### ``META``

To be used for building ``META`` tags in the ``HTML`` head. For example:
``HTML`` 태그안에 ``META``태그를 만드는데 사용됩니다. 예들 들어:

``META``:inxx
``
>>> print META(_name='security', _content='high')
<meta name="security" content="high" />
``:code

##### ``MARKMIN``

Implements the markmin wiki syntax. It converts the input text into output html according to the markmin rules described in the example below:
Markmin 위키 구문을 구현합니다. 입력 테스트를 markmin규칙에 따라 출력 html로 변환합니다.

``MARKMIN``:inxx
``
>>> print MARKMIN("this is **bold** or ''italic'' and this [[a link http://web2py.com]]")
<p>this is <b>bold</b> or <i>italic</i> and
this <a href="http://web2py.com">a link</a></p>
``:code

The markmin syntax is described in this file that ships with web2py:
Markmin 구문은 web2py와 함께 포함된 다음 파일에 기술되어 있습니다:
``
http://127.0.0.1:8000/examples/static/markmin.html
``:code

and some examples are shown in chapter 12 in the context of plugin_wiki, which uses MARKMIN extensively.
그리고 12장에 몇몇 예제는 plugin_wiki 문맥에서 보여지는 것으로 이것은 MARKMIN을 광범위하게 사용합니다.
  
You can use markmin to generate HTML, LaTeX and PDF documents:
Markmin을 이용해서 HTML, LaTex, PDF문서를 생성하는데 사용할 수도 있습니다:

``
m = "Hello **world** [[link http://web2py.com]]"
from gluon.contrib.markmin.markmin2html import markmin2html
print markmin2html(m)
from gluon.contrib.markmin.markmin2latex import markmin2latex
print markmin2latex(m)
from gluon.contrib.markmin.markmin2pdf import markmin2pdf
print markmin2pdf(m) # requires pdflatex
``

(the ``MARKMIN`` helper is a shortcut for ``markmin2html``)
(``MARKIN`` 헬퍼는 ``markmin2html``에 대한 단축입니다.

Here is a basic syntax primer:
다음은 기본 구문입니다:
 
--------------------------------------------------
**SOURCE**                 | **OUTPUT**
``# title``                | **title**
``## section``             | **section**
``### subsection``         | **subsection**
``**bold**``               | **bold**
``''italic''``             | ''italic''
``!`!`verbatim`!`!``       | ``verbatim``
``http://google.com``      | http://google.com
``http://...`` | ``<a href="http://...">http:...</a>``
``http://...png`` | ``<img src="http://...png" />``
``http://...mp3`` | ``<audio src="http://...mp3"></audio>``
``http://...mp4`` | ``<video src="http://...mp4"></video>``
``qr:http://...`` | ``<a href="http://..."><img src="qr code"/></a>``
``embed:http://...`` | ``<iframe src="http://..."></iframe>``
``[[click me #myanchor]]`` | [[click me #myanchor]]
``$````$\int_a^b sin(x)dx$````$``  | $$\int_a^b sin(x)dx$$
---------------------------------------------------

Simply including a link to an image, a videos or an audio files without markup result in the corresponding image, video or audio file being included automatically (for audio and video it uses html <audio> and <video> tags).
간단하게 링크를 이미지, 비디오, 오디오 파일에 포함하거나 markup없이 자동으로 포함됩니다( 오디오와 비디오는 <audio>, <video>태그를 사용합니다).

Adding a link with the ``qr:`` prefix such as
다음과 ``qr:``을 링크 앞에 덧붙이는 것은 

``
qr:http://web2py.com
``

results in the corresponding QR code being embedded and linking the said URL.
해당하는 QR코드가 포함되고 해당 URL을 가르키게 됩니다.
Adding a link with the ``embed:`` prefix such as
``embed:``를 링크 앞에 덧붙이면

``
embed:http://www.youtube.com/embed/x1w8hKTJ2Co
``

results in the page being embedded, in this case a youtube video is embedded.
페이지 안에 포함되는데 이 경우에는 Youtube 비디오가 포함된다.

Images can also be embedded with the following syntax:
이미지는 또한 다음과 같은 구문으로 포함됩니다:

``
[[image-description http://.../image.png right 200px]]
``

Unordered lists with:
비순차 리스트는 다음과 같이 이용:
``
- one
- two
- three
``

Ordered lists with:
순차 리스트는 다음과 같이 이용:
``
+ one
+ two
+ three
``

and tables with:
테이블은 다음과 같이 이용:
``
----------
 X | 0 | 0
 0 | X | 0
 0 | 0 | 1
----------
``

The MARKMIN syntax also supports blockquotes, HTML5 audio and video tags, image alignment, custom css, and it can be extended:
MARKMIN 구문은 블록인용, HTML5 오디오, 비디오 태그, 이미지 정렬, 사용자 CSS를 지원하고 확장될 수 있습니다. 

``
MARKMIN("!`!!`!abab!`!!`!:custom", extra=dict(custom=lambda text: text.replace('a','c'))
``:code

generates
위 코드는 다음을 생성합니다.

``'cbcb'``:code

Custom blocks are delimited by ``!`!!`!...!`!!`!:<key>`` and they are rendered by the function passed as value for the corresponding key in the extra dictionary argument of MARKMIN. Mind that the function may need to escape the output to prevent XSS.
사용자 블럭은 ``!`!!`!...!`!!`!:<key>``로 구분됩니다. 그리고 이 블럭은 함수에  MARKMIN의 extra 사전 인자에 해당 key에 대한 값으로 전달되어 표시됩니다. 함수의 출력은 XSS를 막기위해서 escape이 필요할 것입니다.

##### ``OBJECT``

Used to embed objects (for example, a flash player) in the HTML.
HTML에 객체(예를들어 flash player)등을 포함시키기 위해서 사용된다.

``OBJECT``:inxx
``
>>> print OBJECT('<hello>', XML('<b>world</b>'),
>>>              _src='http://www.web2py.com')
<object src="http://www.web2py.com">&lt;hello&gt;<b>world</b></object>
``:code

##### ``OL``

It stands for Ordered List. The list should contain LI tags. ``OL`` arguments that are not ``LI`` objects are automatically enclosed in ``<li>...</li>`` tags.
순차 리스트를 나타냅니다. 리스트는 LI 태그를 포함하고 있어야 합니다. ``LI`` 객체가 아닌 ``OL``인자는 자동으로 ``<li>...</li>`` 태그로 닫힙니다.

``OL``:inxx
``
>>> print OL('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<ol id="0" class="test"><li>&lt;hello&gt;</li><li><b>world</b></li></ol>
``:code

##### ``ON``

This is here for backward compatibility and it is simply an alias for ``True``. It is used exclusively for checkboxes and deprecated since ``True`` is more Pythonic.
이것은 하위호환성을 위해서 존재하며 단순히 ``True``의 별칭입니다. 이것은 checkbox를 위해서만 사용되며 ``True``가 더 python답기때문에 폐지예정입니다.

``ON``:inxx
``
>>> print INPUT(_type='checkbox', _name='test', _checked=ON)
<input checked="checked" type="checkbox" name="test" />
``:code

##### ``OPTGROUP``

Allows you to group multiple options in a SELECT and it is useful to customize the fields using CSS.
SELECT 태그 안에서 다수의 Option을 묶어줍니다. CSS를 이용해서 필드를 커스터마이즈할때 유용합니다.

``OPTGROUP``:inxx
``
>>> print SELECT('a', OPTGROUP('b', 'c'))
<select>
  <option value="a">a</option>
  <optgroup>
    <option value="b">b</option>
    <option value="c">c</option>
  </optgroup>
</select>
``:code

##### ``OPTION``

This should only be used as part of a SELECT/OPTION combination.
이것은 SELECT/OPTION 조합의 부분으로만 사용되어야 합니다.

``OPTION``:inxx
``
>>> print OPTION('<hello>', XML('<b>world</b>'), _value='a')
<option value="a">&lt;hello&gt;<b>world</b></option>
``:code

As in the case of ``INPUT``, web2py make a distinction between "_value" (the value of the OPTION), and "value" (the current value of the enclosing select). If they are equal, the option is "selected".
이 ``INPUT``의 경우 web2py는 "_value"(OPTION의 값)과 "value"(포함하는 SELECT의 현재값)과 구분합니다. 만약에 이값이 서로 같다면 해당 OPTION은 "selected"가 됩니다.

``selected``:inxx
``
>>> print SELECT('a', 'b', value='b'):
<select>
<option value="a">a</option>
<option value="b" selected="selected">b</option>
</select>
``:code

##### ``P``
``P``:inxx

This is for tagging a paragraph.
문단을 위한 태그입니다.
``
>>> print P('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<p id="0" class="test">&lt;hello&gt;<b>world</b></p>
``:code

##### ``PRE``
``PRE``:inxx

Generates a ``<pre>...</pre>`` tag for displaying pre-formatted text. The ``CODE`` helper is generally preferable for code listings.
미리 형식화된 텍스트를 표시하기 위한 ``<pre>...</pre>`` 태그를 생성합니다. ``CODE``헬퍼는 일반적으로 코드를 리스트하는데 사용합니다.
``
>>> print PRE('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<pre id="0" class="test">&lt;hello&gt;<b>world</b></pre>
``:code

##### ``SCRIPT``
``SCRIPT``:inxx

This is include or link a script, such as JavaScript. The content between the tags is rendered as an HTML comment, for the benefit of really old browsers.
이것은 자바스크립트같은 스크립트를 포함하거나 연결합니다. 태그사이의 컨텐트는 이전 브라우저를 위해서 HTML 주석으로 표시됩니다.
``
>>> print SCRIPT('alert("hello world");', _type='text/javascript')
<script type="text/javascript"><!--
alert("hello world");
//--></script>
``:code

##### ``SELECT``
``SELECT``:inxx

Makes a ``<select>...</select>`` tag. This is used with the ``OPTION`` helper. Those ``SELECT`` arguments that are not ``OPTION`` objects are automatically converted to options.
``<select>...</select>``태그를 만들며  ``OPTION``헬퍼와 함께 사용됩니다. ``OPTION`` 객체가 아닌 ``SELECT``인자는 자동으로 option으로 변환됩니다. 
``
>>> print SELECT('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<select id="0" class="test">
   <option value="&lt;hello&gt;">&lt;hello&gt;</option>
   <option value="&lt;b&gt;world&lt;/b&gt;"><b>world</b></option>
</select>
``:code

##### ``SPAN``
``SPAN``:inxx

Similar to ``DIV`` but used to tag inline (rather than block) content.
``DIV``와 비슷하지만 인라인 컨텐트를 태그하는데 사용됩니다.
``
>>> print SPAN('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<span id="0" class="test">&lt;hello&gt;<b>world</b></span>
``:code

##### ``STYLE``
``STYLE``:inxx

Similar to script, but used to either include or link CSS code.
Here the CSS is included:
script와 비슷하지만 CSS 코드를 링크가거나 포함하는데 사용됩니다. 다음은 포함된 CSS입니다.
``
>>> print STYLE(XML('body {color: white}'))
<style><!--
body { color: white }
//--></style>
``:code

and here it is linked:
이것은 링크된 것입니다:
``
>>> print STYLE(_src='style.css')
<style src="style.css"><!--
//--></style>
``:code

##### ``TABLE``, ``TR``, ``TD``
``TABLE``:inxx ``TR``:inxx ``TD``:inxx

These tags (along with the optional ``THEAD``, ``TBODY`` and ``TFOOTER`` helpers) are used to build HTML tables.
이들 태그는(``THREAD``, ``TBODY``, ``TFOOTER``헬퍼와 함께) HTML테이블을 만드는데 사용됩니다.
``
>>> print TABLE(TR(TD('a'), TD('b')), TR(TD('c'), TD('d')))
<table><tr><td>a</td><td>b</td></tr><tr><td>c</td><td>d</td></tr></table>
``:code
``TR`` expects ``TD`` content; arguments that are not ``TD`` objects are converted automatically.
``TR``은 ``TD`` 컨텐트를 예상합니다; ``TD``객체가 아닌 인자는 자동으로 변환됩니다. 
<table><tr><td>a</td><td>b</td></tr><tr><td>c</td><td>d</td></tr></table>
``:code

It is easy to convert a Python array into an HTML table using Python's ``*`` function arguments notation, which maps list elements to positional function arguments.
파이선 배열를 HTML 테이블로 변환하는 것은 쉽습니다. Python ``*`` 함수 인자 표기법을 사용해서 리스트의 각 요소를 위치기반 함수 인자로 매핑합니다.
Here, we will do it line by line:
여기서는 이것을 한줄한줄 해볼것입니다:
``
>>> table = [['a', 'b'], ['c', 'd']]
>>> print TABLE(TR(*table[0]), TR(*table[1]))
<table><tr><td>a</td><td>b</td></tr><tr><td>c</td><td>d</td></tr></table>
``:code

Here we do all lines at once:
이번엔 모든 라인을 한번에 해봅니다:
``
>>> table = [['a', 'b'], ['c', 'd']]
>>> print TABLE(*[TR(*rows) for rows in table])
<table><tr><td>a</td><td>b</td></tr><tr><td>c</td><td>d</td></tr></table>
``:code

##### ``TBODY``
``TBODY``:inxx

This is used to tag rows contained in the table body, as opposed to header or footer rows. It is optional.
테이블 몸체에 포함되는 행(반대로 머리말이나 꼬리말 row가 있음)을 태그하는데 사용되며 선택 사항입니다. 
``
>>> print TBODY(TR('<hello>'), _class='test', _id=0)
<tbody id="0" class="test"><tr><td>&lt;hello&gt;</td></tr></tbody>
``:code

##### ``TEXTAREA``
``TEXTAREA``:inxx

This helper makes a ``<textarea>...</textarea>`` tag.
이 헬퍼는 ``<textarea>...</textarea>``태그를 만듭니다.
``
>>> print TEXTAREA('<hello>', XML('<b>world</b>'), _class='test')
<textarea class="test" cols="40" rows="10">&lt;hello&gt;<b>world</b></textarea>
``:code

The only caveat is that its optional "value" overrides its content (inner HTML)
하나 주의할 점은 선택사항인 "value"가 컨텐트(내부 HTML)을 덮어쓴다는 것입니다.
``
>>> print TEXTAREA(value="<hello world>", _class="test")
<textarea class="test" cols="40" rows="10">&lt;hello world&gt;</textarea>
``:code

##### ``TFOOT``
``TFOOT``:inxx

This is used to tag table footer rows.
테이블의 꼬리말 행을 태그하는데 사용됩니다.
``
>>> print TFOOT(TR(TD('<hello>')), _class='test', _id=0)
<tfoot id="0" class="test"><tr><td>&lt;hello&gt;</td></tr></tfoot>
``:code

##### ``TH``
``TH``:inxx

This is used instead of ``TD`` in table headers.
테이블 헤더에서 ``TD``대신에 사용됩니다.
``
>>> print TH('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<th id="0" class="test">&lt;hello&gt;<b>world</b></th>
``:code

##### ``THEAD``
``THEAD``:inxx

This is used to tag table header rows.
테이블 머리말 행을 태그하는데 사용됩니다.
``
>>> print THEAD(TR(TH('<hello>')), _class='test', _id=0)
<thead id="0" class="test"><tr><th>&lt;hello&gt;</th></tr></thead>
``:code

##### ``TITLE``
``TITLE``:inxx

This is used to tag the title of a page in an HTML header.
HTML헬퍼안에 페이지의 타이틀을 태그화하는데 사용됩니다.
``
>>> print TITLE('<hello>', XML('<b>world</b>'))
<title>&lt;hello&gt;<b>world</b></title>
``:code

##### ``TR``
``TR``:inxx

Tags a table row. It should be rendered inside a table and contain ``<td>...</td>`` tags. ``TR`` arguments that are not ``TD`` objects will be automatically converted.
테이블 행을 태그화합니다. 이것은 테이블 내부에서 표시되어야 하고 ``<td>...</td>``태그를 포함합니다. ``TD``객체가 아닌 ``TR`` 인자는 자동으로 변환됩니다.
``
>>> print TR('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<tr id="0" class="test"><td>&lt;hello&gt;</td><td><b>world</b></td></tr>
``:code

##### ``TT``
``TT``:inxx

Tags text as typewriter (monospaced) text.
텍스트를 타자기 텍스트로 태그화합니다.
``
>>> print TT('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<tt id="0" class="test">&lt;hello&gt;<b>world</b></tt>
``:code

##### ``UL``

Signifies an Unordered List and should contain LI items. If its content is not tagged as LI, UL does it automatically.
순서없는 리스트를 나타내면 LI를 포함해야 합니다. UL의 컨텐트가 LI로 태그되지 않았다면 UL이 자동으로 태그화 합니다.

``UL``:inxx
``
>>> print UL('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<ul id="0" class="test"><li>&lt;hello&gt;</li><li><b>world</b></li></ul>
``:code

##### ``embed64``

``embed64(filename=None, file=None, data=None, extension='image/gif')`` encodes the provided (binary) data into base64.
``embed64(filename=None, file=None, data=None, extension='image/gif')`` (바이너리) 테이터를 base64로 인코딩합니다.

filename: if provided, opens and reads this file in 'rb' mode.
file: if provided, reads this file.
data: if provided, uses the provided data.
filename: 주어진 경우 'rb'모드로 열고 파일을 읽습니다.
file: 주어진경우, 파일을 읽습니다.
data: 주어진 경우, 데이터를 사용합니다.

``embed64``:inxx

##### ``xmlescape``

``xmlescape(data, quote=True)`` returns an escaped string of the provided data.
``xmlescape(data, quote=True)`` 데이터를 escape된 문자열로 반환합니다.

``xmlescape``:inxx
``
>>> print xmlescape('<hello>')
&lt;hello&gt;
``:code

#### Custom helpers

##### ``TAG``
``TAG``:inxx

Sometimes you need to generate custom XML tags. web2py provides ``TAG``, a universal tag generator.
때로는 사용자 XML 태그를 생성해야 할때가 있습니다. Web2py는 ``TAG``라는 범용적인 태그 생성기를 제공합니다.
``
{{=TAG.name('a', 'b', _c='d')}}
``:code

generates the following XML
다음과 같은 XML을 생성합니다.
``
<name c="d">ab</name>
``:code

Arguments "a", "b", and "d" are automatically escaped; use the ``XML`` helper to suppress this behavior. Using ``TAG`` you can generate HTML/XML tags not already provided by the API. TAGs can be nested, and are serialized with ``str().``
인자 "a", "b", "d"는 자동으로 escape되기때문에 , 자동 변환를 막기 위해서 ``XML`` 헬퍼를 사용합니다. ``TAG``를 사용해서 API로 제공하지 않는 HTML/XML 태그를 생성할수 있습니다.  TAG는 중첩될수 있고 ``str0``를 통해서 직렬화할 수 있습니다.
An equivalent syntax is:
동일한 구문은 다음과 같습니다.
``
{{=TAG['name']('a', 'b', c='d')}}
``:code

If the TAG object is created with an empty name, it can be used to concatenate multiple strings and HTML helpers together without inserting them into a surrounding tag, but this use is deprecated. Use the ``CAT`` helper instead.
TAG 객체가 빈 이름으로 생성된 경우 다수의 스트링을 합치고 HTML 헬퍼들이 둘러싸는 태그를 생성하지 않고 함께 합니다. 하지만 이것은 폐지예정이며 ``CAT`` 헬퍼를 사용하세요.

Notice that ``TAG`` is an object, and ``TAG.name`` or ``TAG['name']`` is a function that returns a temporary helper class.
``TAG``는 객체이고 ``TAG.name``이나 ``TAG['name']``는 임시 헬퍼 클래스를 반환하는 함수라는 사실에 주목하세요.

##### ``MENU``
``MENU``:inxx

The MENU helper takes a list of lists or of tuples of the form of ``response.menu`` (as described in Chapter 4) and generates a tree-like structure using unordered lists representing the menu. For example:
MENU  헬퍼는 리스트의 리스트나 ``response.menu``의 형태와 같은 튜플에 대한 리스트 (4장에서 설명)를 취하고 메뉴를 나타내는 순서없는 리스트를 이용해서 트리와 같이 구조를 생성합니다.
``
>>> print MENU([['One', False, 'link1'], ['Two', False, 'link2']])
<ul class="web2py-menu web2py-menu-vertical">
  <li><a href="link1">One</a></li>
  <li><a href="link2">Two</a></li>
</ul>
``:code

Each menu item can have a fourth argument that is a nested submenu (and so on recursively):
각 메뉴 아이템은 4번째 인자를 갖고 이것은 중첩된 부메뉴를 나타닙니다.(이런식으로 재귀적으로 정의됩니다.):
``
>>> print MENU([['One', False, 'link1', [['Two', False, 'link2']]]])
<ul class="web2py-menu web2py-menu-vertical">
  <li class="web2py-menu-expand">
     <a href="link1">One</a>
     <ul class="web2py-menu-vertical">
        <li><a href="link2">Two</a></li>
     </ul>
  </li>
</ul>
``:code

A menu item can also have an optional 5th element, which is a boolean. When false, the menu item is ignored by the MENU helper.
또한 하나의 메뉴 아이템은 선택적으로 다섯번째 요소를 가질수 있는데 그것은 boolean입니다. false인 경우는 메뉴 아이템이 MENU헬퍼에 의해서 무시됩니다.

The MENU helper takes the following optional arguments:
- ``_class``: defaults to "web2py-menu web2py-menu-vertical" and sets the class of the outer UL elements.
- ``ul_class``: defaults to "web2py-menu-vertical" and sets the class of the inner UL elements.
- ``li_class``: defaults to "web2py-menu-expand" and sets the class of the inner LI elements.
MENU 헬퍼는 다음과 같은 선택적은 인자를 갖습니다.
- ``_class``: 는 "web2py-menu web2py-menu-vertical"의 기본값이 주어지고 바깥 UL 요소의 클래스를 설정합니다.
- ``ul_class``는 "web2py-menu-vertical"로 기본값이 주어지고 내부 UL요소의 클래스를 설정합니다.
-. ``li_class``는 "web2py-menu-expand"로 기본값이 주어지고 내부 LI요소의 클래스를 설정합니다.


``mobile``:inxx

``MENU`` takes an optional argument ``mobile``. When set to ``True`` instead of building a recursive ``UL`` menu structure it returns a ``SELECT`` dropdown with all the menu options and a ``onchange`` attribute that redirects to the page corresponding to the selected option. This is designed an an alternative menu representation that increases usability on small mobile devices such as phones.
``MENU``는  임의의 인자 ``mobile``을 갖습니다. 재귀적인 ``True``로 설정하면 ``UL`` 메뉴 구조를 재귀적으로 만드는것 대신에 모든 메뉴 옵션들을 갖는 ``SELECT`` dropdown을 리턴하고 메뉴 옵션과 선택된 옵션에 해당하는 페이지로 리다이렉트하는 ``onchange`` 속성을 리턴한다. 폰과 같은 작은 장치에서 사용성이 증가될 수 있도록 표시하는 대체 메뉴를 나타내도록 설계되었다. 

Normally the menu is used in a layout with the following syntax:
보통 메뉴는 다음과 같은 구문으로 레이아웃에서 사용된다.

``
{{=MENU(response.menu, mobile=request.user_agent().is_mobile)}}
``

In this way a mobile device is automatically detected and the menu is rendered accordingly.
이런 방법으로 모바일 장치는 자동적으로 인식되고 메뉴는 그에따라 표시되어집니다.

### ``BEAUTIFY``
``BEAUTIFY`` is used to build HTML representations of compound objects, including lists, tuples and dictionaries:
``BEAUTIFY``는 리스트, 튜플, 사전등을 포함하고 있는 복합객체를 나타내는 HTML을 생성하는데 사용된다.
``
{{=BEAUTIFY({"a": ["hello", XML("world")], "b": (1, 2)})}}
``:code
``BEAUTIFY`` returns an XML-like object serializable to XML, with a nice looking representation of its constructor argument. In this case, the XML representation of:
``BEAUTIFY``는 XML로 객체 직렬화할수 있는 XML같은  객체를 리턴한다.  
TBD
``
{"a": ["hello", XML("world")], "b": (1, 2)}
``:code

will render as:
``
<table>
<tr><td>a</td><td>:</td><td>hello<br />world</td></tr>
<tr><td>b</td><td>:</td><td>1<br />2</td></tr>
</table>
``:code

### Server-side ''DOM'' and parsing
``element``:inxx ``elements``:inxx

#### ``elements``

The DIV helper and all derived helpers provide the search methods ``element`` and ``elements``.

``element`` returns the first child element matching a specified condition (or None if no match).

``elements`` returns a list of all matching children.

**element** and **elements** use the same syntax to specify the matching condition, which allows for three possibilities that can be mixed and matched: jQuery-like expressions, match by exact attribute value, match using regular expressions.

Here is a simple example:
``
>>> a = DIV(DIV(DIV('a', _id='target',_class='abc')))
>>> d = a.elements('div#target')
>>> d[0][0] = 'changed'
>>> print a
<div><div><div id="target" class="abc">changed</div></div></div>
``:code

The un-named argument of ``elements`` is a string, which may contain: the name of a tag, the id of a tag preceded by a pound symbol, the class preceded by a dot, the explicit value of an attribute in square brackets.

Here are 4 equivalent ways to search the previous tag by id:
``
>>> d = a.elements('#target')
>>> d = a.elements('div#target')
>>> d = a.elements('div[id=target]')
>>> d = a.elements('div',_id='target')
``:code

Here are 4 equivalent ways to search the previous tag by class:
``
>>> d = a.elements('.abc')
>>> d = a.elements('div.abc')
>>> d = a.elements('div[class=abc]')
>>> d = a.elements('div',_class='abc')
``:code

Any attribute can be used to locate an element (not just ``id`` and ``class``), including multiple attributes (the function element can take multiple named arguments), but only the first matching element will be returned.

Using the jQuery syntax "div#target" it is possible to specify multiple search criteria separated by a space:
``
>>> a = DIV(SPAN('a', _id='t1'), DIV('b', _class='c2'))
>>> d = a.elements('span#t1, div.c2')
``:code

or equivalently
``
>>> a = DIV(SPAN('a', _id='t1'), DIV('b', _class='c2'))
>>> d = a.elements('span#t1', 'div.c2')
``:code

If the value of an attribute is specified using a name argument, it can be a string or a regular expression:
``
>>> a = DIV(SPAN('a', _id='test123'), DIV('b', _class='c2'))
>>> d = a.elements('span', _id=re.compile('test\d{3}')
``:code

A special named argument of the DIV (and derived) helpers is ``find``. It can be used to specify a search value or a search regular expression in the text content of the tag. For example:
``
>>> a = DIV(SPAN('abcde'), DIV('fghij'))
>>> d = a.elements(find='bcd')
>>> print d[0]
<span>abcde</span>
``:code

or
``
>>> a = DIV(SPAN('abcde'), DIV('fghij'))
>>> d = a.elements(find=re.compile('fg\w{3}'))
>>> print d[0]
<div>fghij</div>
``:code

#### ``components``
Here's an example of listing all elements in an html string:
``
html = TAG('<a>xxx</a><b>yyy</b>')
for item in html.components: print item
``:code

#### ``parent``
``parent`` returns the parent of the current element.
``
>>> a = DIV(SPAN('a'),DIV('b'))
>>> d = a.element('a').parent()
>>> d['_class']='abc'
>>> print a
<div class="abc"><span>a</span><div>b</div></div>
``:code

#### ``flatten``

The flatten method recursively serializes the content of the children of a given element into regular text (without tags):
``
>>> a = DIV(SPAN('this', DIV('is', B('a'))), SPAN('test'))
>>> print a.flatten()
thisisatest
``:code

Flatten can be passed an optional argument, ``render``, i.e. a function that renders/flattens the content using a different protocol. Here is an example to serialize some tags into Markmin wiki syntax:
``
>>> a = DIV(H1('title'), P('example of a ', A('link', _href='#test')))
>>> from gluon.html import markmin_serializer
>>> print a.flatten(render=markmin_serializer)
## titles

example of [[a link #test]]
``:code

At the time of writing we provide ``markmin_serializer`` and ``markdown_serializer``.

#### Parsing

The TAG object is also an XML/HTML parser. It can read text and convert into a tree structure of helpers. This allows manipulation using the API above:
``
>>> html = '<h1>Title</h1><p>this is a <span>test</span></p>'
>>> parsed_html = TAG(html)
>>> parsed_html.element('span')[0]='TEST'
>>> print parsed_html
<h1>Title</h1><p>this is a <span>TEST</span></p>
``:code

### Page layout
``page layout``:inxx ``layout.html``:inxx ``extent``:inxx ``include``:inxx

Views can extend and include other views in a tree-like structure.

For example, we can think of a view "index.html" that extends "layout.html" and includes "body.html".
At the same time,  "layout.html" may include "header.html" and "footer.html".

The root of the tree is what we call a layout view.  Just like any other HTML template file, you can edit it using the web2py administrative interface. The file name "layout.html" is just a convention.

Here is a minimalist page that extends the "layout.html" view and includes the "page.html" view:

``
{{extend 'layout.html'}}
<h1>Hello World</h1>
{{include 'page.html'}}
``:code

The extended layout file must contain an ``{{include}}`` directive, something like:
``
<html>
  <head>
    <title>Page Title</title>
  </head>
  <body>
    {{include}}
  </body>
</html>
``:code

When the view is called, the extended (layout) view is loaded, and the calling view replaces the ``{{include}}`` directive inside the layout. Processing continues recursively until all ``extend`` and ``include`` directives have been processed. The resulting template is then translated into Python code. Note, when an application is bytecode compiled, it is this Python code that is compiled, not the original view files themselves. So, the bytecode compiled version of a given view is a single .pyc file that includes the Python code not just for the original view file, but for its entire tree of extended and included views.

-------
``extend``, ``include``, ``block`` and ``super`` are special template directives,
not Python commands.
-------

Any content or code that precedes the ``{{extend ...}}`` directive will be inserted (and therefore executed) before the beginning of the extended view's content/code. Although this is not typically used to insert actual HTML content before the extended view's content, it can be useful as a means to define variables or functions that you want to make available to the extended view. For example, consider a view "index.html":
``
{{sidebar_enabled=True}}
{{extend 'layout.html'}}
<h1>Home Page</h1>
``:code

and an excerpt from "layout.html":
``
{{if sidebar_enabled:}}
    <div id="sidebar">
        Sidebar Content
    </div>
{{pass}}
``:code

Because the ``sidebar_enabled`` assignment in "index.html" comes before the ``extend``, that line gets inserted before the beginning of "layout.html", making ``sidebar_enabled`` available anywhere within the "layout.html" code (a somewhat more sophisticated version of this is used in the **welcome** app).

It is also worth pointing out that the variables returned by the controller function are available not only in the function's main view, but in all of its extended and included views as well.

The argument of an ``extend`` or ``include`` (i.e., the extended or included view name) can be a python variable (though not a python expression). However, this imposes a limitation -- views that use variables in ``extend`` or ``include`` statements cannot be bytecode compiled. As noted above, bytecode-compiled views include the entire tree of extended and included views, so the specific extended and included views must be known at compile time, which is not possible if the view names are variables (whose values are not determined until run time). Because bytecode compiling views can provide a significant speed boost, using variables in ``extend`` and ``include`` should generally be avoided if possible.

In some cases, an alternative to using a variable in an ``include`` is simply to place regular ``{{include ...}}`` directives inside an ``if...else`` block.

``
{{if some_condition:}}
{{include 'this_view.html'}}
{{else:}}
{{include 'that_view.html'}}
{{pass}}
``:code

The above code does not present any problem for bytecode compilation because no variables are involved. Note, however, that the bytecode compiled view will actually include the Python code for both "this_view.html" and "that_view.html", though only the code for one of those views will be executed, depending on the value of ``some_condition``.

Keep in mind, this only works for ``include`` -- you cannot place ``{{extend ...}}`` directives inside ``if...else`` blocks.

``response.menu``:inxx ``menu``:inxx ``response.meta``:inxx ``meta``:inxx

Layouts are used to encapsulate page commonality (headers, footers, menus), and though they are not mandatory, they will make your application easier to write and maintain.  In particular, we suggest writing layouts that take advantage of the following variables that can be set in the controller. Using these well known variables will help make your layouts interchangeable:
``
response.title
response.subtitle
response.meta.author
response.meta.keywords
response.meta.description
response.flash
response.menu
response.files
``:code

Except for ``menu`` and ``files``, these are all strings and their meaning should be obvious.

``response.menu`` menu is a list of 3-tuples or 4-tuples. The three elements are: the link name, a boolean representing whether the link is active (is the current link), and the URL of the linked page. For example:
``
response.menu = [('Google', False, 'http://www.google.com',[]),
                 ('Index',  True,  URL('index'), [])]
``:code

``sub-menu``:inxx
The fourth tuple element is an optional sub-menu.

``response.files`` is a list of CSS and JS files that are needed by your page.

We also recommend that you use:

``
{{include 'web2py_ajax.html'}}
``:code

in the HTML head, since this will include the jQuery libraries and define some backward-compatible JavaScript functions for special effects and Ajax. "web2py_ajax.html" includes the ``response.meta`` tags in the view, jQuery base, the calendar datepicker, and all required CSS and JS ``response.files``.

#### Default page layout
``superfish``:inxx ``ez.css``:inxx

Below is the "views/layout.html" that ships with the web2py scaffolding application **welcome** (stripped down of some optional parts). Any new application will have a similar default layout:

``
<!DOCTYPE html>
<head>
  <meta charset="utf-8" />
  <title>{{=response.title or request.application}}</title>

  <!-- http://dev.w3.org/html5/markup/meta.name.html -->
  <meta name="application-name" content="{{=request.application}}" />

  <script src="{{=URL('static','js/modernizr.custom.js')}}"></script>

  <!-- include stylesheets -->
  {{
  response.files.append(URL('static','css/skeleton.css'))
  response.files.append(URL('static','css/web2py.css'))
  response.files.append(URL('static','css/superfish.css'))
  response.files.append(URL('static','js/superfish.js'))
  }}

  {{include 'web2py_ajax.html'}}

  <script type="text/javascript">
    jQuery(function(){ jQuery('ul.sf-menu').supersubs({minWidth:12,maxWidth:30,extraWidth:3}).superfish(); });
  </script>

  {{
  # using sidebars need to know what sidebar you want to use
  left_sidebar_enabled = globals().get('left_sidebar_enabled',False)
  right_sidebar_enabled = globals().get('right_sidebar_enabled',False)
  middle_columns = {0:'sixteen',1:'twelve',2:'eight'}[
     (left_sidebar_enabled and 1 or 0)+(right_sidebar_enabled and 1 or 0)]
  }}

</head>
<body>
  <div class="wrapper"><!-- for sticky footer -->

    <div class="topbar">
      <div class="container">
        <div class="sixteen columns">
          <div id="navbar">
            {{='auth' in globals() and auth.navbar(separators=(' ',' | ',''))}}
          </div>
          <div id="menu">
            {{=MENU(response.menu,
                    _class='mobile-menu' if is_mobile else 'sf-menu',
                    mobile=request.user_agent().is_mobile)}}
          </div>
        </div>
      </div>
    </div><!-- topbar -->

    <div class="flash">{{=response.flash or ''}}</div>

    <div class="header">
      <div class="container">
        <div class="sixteen columns">
          <h1 class="remove-bottom" style="margin-top: .5em;">
          {{=response.title or request.application}}
          </h1>
          <h5>{{=response.subtitle or ''}}</h5>
        </div>

        <div class="sixteen columns">
          <div class="statusbar">
            {{block statusbar}}
            <span class="breadcrumbs">{{=request.function}}</span>
            {{end}}
          </div>
        </div>
      </div>
    </div>

    <div class="main">
      <div class="container">
        {{if left_sidebar_enabled:}}
        <div class="four columns left-sidebar">
          {{block left_sidebar}}
          <h3>Left Sidebar</h3>
          <p></p>
          {{end}}
        </div>
        {{pass}}

        <div class="{{=middle_columns}} columns center">
          {{block center}}
          {{include}}
          {{end}}
        </div>

        {{if right_sidebar_enabled:}}
        <div class="four columns">
          {{block right_sidebar}}
          <h3>Right Sidebar</h3>
          <p></p>
          {{end}}
        </div>
        {{pass}}

      </div><!-- container -->
    </div><!-- main -->

    <div class="push"></div>
  </div><!-- wrapper -->

  <div class="footer">
    <div class="container header">
      <div class="sixteen columns">
        {{block footer}} <!-- this is default footer -->
        <div class="footer-content" >
          {{=T('Copyright')}} &#169; 2011
          <div style="float: right;">
            <a href="http://www.web2py.com/">
            <img style="padding-bottom: 0;"
                 src="{{=URL('static','images/poweredby.png')}}"/>
            </a>
          </div>
        </div>
        {{end}}
      </div>
    </div><!-- container -->
  </div><!-- footer -->

</body>
</html>

``:code

There are a few features of this default layout that make it very easy to use and customize:

- It is written in HTML5 and uses the "modernizr" ``modernizr``:cite library for backward compatibility. The actual layout include some extra conditional statements required by IE and they are omitted for brevity.
- It displays both ``response.title`` and ``response.subtitle`` which can be set in a model. If they are not set, it adopts the application name as title
- It includes the ``web2py_ajax.html`` file in the header which generated all the link and script import statements.
- It uses a modified version of "skeleton" ``skeleton``:cite a library for flexible layouts which works on mobile devices and re-arranges columns to fit small screens.
- It uses "superfish.js" ``superfish``:cite for dynamic cascading menus. There is an explicit script to activate the superfish cascading menu and it can be removed if not necessary.
- The ``{{=auth.navbar(...)}}`` displays a welcome to the current user and links to auth functions like login, logout, register, change password, etc. depending on context. It is a helper factory and its output can be manipulated as any other helper. It is placed in a ``{{try:}}...{{except:pass}}`` in case auth is undefined.
- The ``{{=MENU(response.menu)`` displays the menu structure as ``<ul>...</ul>``.
- ``{{include}}`` is replaced by the content of the extending view when the page is rendered.
- By default it uses a conditional three column (the left and right sidebars can be turned off by the extending views)
- It uses the following classes: header, main, footer
- It contains the following blocks: statusbar, left_sidebar, center, right_sidebar, footer.

Views can turn on and fill sidebars as follows:

``
{{left_sidebar_enable=True}}
{{extend 'layout.html'}}

This text goes in center

{{block left_sidebar}}
This text goes in sidebar
{{end}}
``:code

#### Customizing the default layout

``CSS``:inxx

Customizing the default layout without editing is very easy because the CSS files are documented:

- "bootstrap.min.css" contains the Twitter Boostrap CSS style ``bootstrap``:cite ``Bootstrap``:inxx
- "web2py.css" contains web2py specific styles

To change colors and background images,
try append the following code to layout.html header:

``
<style>
body { background: url('images/background.png') repeat-x #3A3A3A; }
a { color: #349C01; }
.header h1 { color: #349C01; }
.header h2 { color: white; font-style: italic; font-size: 14px;}
.statusbar { background: #333333; border-bottom: 5px #349C01 solid; }
.statusbar a { color: white; }
.footer { border-top: 5px #349C01 solid; }
</style>
``:code

Of course you can also completely replace the "layout.html" and "web2py.css" files with your own.

#### Mobile development

The default layout.html is designed to be friendly to mobile devices but that is not enough. One may need to use different views when a page is visited by a mobile device.

To make developing for desktop and mobile devices easier, web2py includes the ``@mobilize`` decorator. This decorator is applied to actions that should have a normal view and a mobile view. This is demonstrated here:

``
from gluon.contrib.user_agent_parser import mobilize
@mobilize
def index():
   return dict()
``

Notice that the decorator must be imported before using it in a controller.
When the "index" function is called from a regular browser (desktop computer), web2py will render the returned dictionary using the view "[controller]/index.html". However, when it is called by a mobile device, the dictionary will be rendered by "[controller]/index.mobile.html". Notice that mobile views have the "mobile.html" extension.

Alternatively you can apply the following logic to make all views mobile friendly:

``
if request.user_agent().is_mobile:
    response.view.replace('.html','.mobile.html')
``

The task of creating the "*.mobile.html" views is left to the developer but we strongly suggest using the "jQuery Mobile" plugin which makes the task very easy.

### Functions in views

Consider this "layout.html":

``
<html>
  <body>
    {{include}}
    <div class="sidebar">
      {{if 'mysidebar' in globals():}}{{mysidebar()}}{{else:}}
        my default sidebar
      {{pass}}
    </div>
  </body>
</html>
``:code

and this extending view

``
{{def mysidebar():}}
my new sidebar!!!
{{return}}
{{extend 'layout.html'}}
Hello World!!!
``:code

Notice the function is defined before the ``{{extend...}}`` statement -- this results in the function being created before the "layout.html" code is executed, so the function can be called anywhere within "layout.html", even before the ``{{include}}``. Also notice the function is included in the extended view without the ``=`` prefix.

The code generates the following output:

``
<html>
  <body>
    Hello World!!!
    <div class="sidebar">
        my new sidebar!!!
    </div>
  </body>
</html>
``:code

Notice that the function is defined in HTML (although it could also contain Python code) so that ``response.write`` is used to write its content (the function does not return the content). This is why the layout calls the view function using ``{{mysidebar()}}`` rather than ``{{=mysidebar()}}``. Functions defined in this way can take arguments.

### Blocks in views
``block``:inxx

Another way to make a view more modular is by using ``{{block...}}s`` and this mechanism is an alternative to the mechanism discussed in the previous section.

Consider this "layout.html":

``
<html>
  <body>
    {{include}}
    <div class="sidebar">
      {{block mysidebar}}
        my default sidebar
      {{end}}
    </div>
  </body>
</html>
``:code

and this extending view

``
{{extend 'layout.html'}}
Hello World!!!
{{block mysidebar}}
my new sidebar!!!
{{end}}
``:code

It generates the following output:

``
<html>
  <body>
    Hello World!!!
    <div class="sidebar">
        my new sidebar!!!
    </div>
  </body>
</html>
``:code

You can have many blocks, and if a block is present in the extended view but not in the extending view, the content of the extended view is used. Also, notice that unlike with functions, it is not necessary to define blocks before the ``{{extend ...}}`` -- even if defined after the ``extend``, they can be used to make substitutions anywhere in the extended view.

``super``:inxx

Inside a block, you can use the expression ``{{super}}`` to include the content of the parent. For example, if we replace the above extending view with:

``
{{extend 'layout.html'}}
Hello World!!!
{{block mysidebar}}
{{super}}
my new sidebar!!!
{{end}}
``:code

we get:

``
<html>
  <body>
    Hello World!!!
    <div class="sidebar">
        my default sidebar
        my new sidebar!!!
    </div>
  </body>
</html>
``:code
