## Overview

### Startup

``Linux``:inxx ``Mac``:inxx ``Windows``:inxx

web2py comes in binary packages for Windows and Mac OS X. They include the Python interpreter so you do not need to have it pre-installed. There is also a source code version that runs on Windows, Mac, Linux, and other Unix systems. The Windows and OS X binary versions include the necessary Python interpreter. The source code package assumes that Python is already installed on the computer.

web2py는 Windows와 Mac OS X에서는 바이너리 패키지로 제공됩니다. 여기에는 Python 인터프리터가 포함되어 있어서 따로 인스톨할 필요가 없습니다. 또한 Windows, Mac, Windows뿐만 아니라 다른 Unix 시스템에서 실행할 수 있는 소스 형태 배포도 존재합니다. Windows 와 OS X 바이너리 버전에는 필요한 Python 인터프리터가 포함되어 있습니다. 소스코드 패키지는 컴퓨터에 이미 Python이 설치되어 있다고 가정합니다.

web2py requires no installation. To get started, unzip the downloaded zip file for your specific operating system and execute the corresponding ``web2py`` file.
web2py는 설치가 필요하지 않습니다. 시작하기 위해서는 OS에 맞는 zip파일을 다운로드한후  unzip하고  web2py 파일을 실행하면 됩니다.

On Windows, run:
윈도우에서 실행하는 경우
``
web2py.exe
``:code

On OS X, run:
OS X에서 실행하는 경우 
``
open web2py.app
``:code

On Unix and Linux, run from source by typing:
Unix와 Linux에서는 소스코드에서 실행합니다.
``
python2.5 web2py.py
``:code

To run web2py on Windows from source install first  [[Mark Hammond's "Python for Windows extensions http://sourceforge.net/projects/pywin32/]], then run:
Windows에서 소스코드에서 web2py를 실행하기 위해서는 먼저 [[Mark Hammond's "Python for Windows extensions http://sourceforge.net/projects/pywin32/]]를 설치해야 합니다.
``
python2.5 web2py.py
``:code


The web2py program accepts various command line options which are discussed later.
web2py 프로그램은 여러가지 명령옵션을 사용할수 있으며 이것은 나중에 살펴볼 것입니다.

By default, at startup, web2py displays a startup window and then displays a GUI widget that asks you to choose a one-time administrator password, the IP address of the network interface to be used for the web server, and a port number from which to serve requests. By default, web2py runs its web server on 127.0.0.1:8000 (port 8000 on localhost), but you can run it on any available IP address and port. You can query the IP address of your network interface by opening a command line and typing ``ipconfig`` on Windows or ``ifconfig`` on OS X and Linux. From now on we assume web2py is running on localhost (127.0.0.1:8000). Use 0.0.0.0:80 to run web2py publicly on any of your network interfaces.
실행할때 기본으로 web2py는 시작 윈도우를 표시한 후에 admin 암호, web server에서 사용할 네트웍 인터페이스의 IP 주소를 선택하는 GUI widget을 표시합니다. 네트웍 인터페이스의 IP 주소를 얻기 위해서는 Windows의 경우  도스창에서 ``ipconfig``를 입력하고 OS X 나 Linux의 경우 ``ifconfig``를 입력하면 됩니다. 이제부터 web2py는 localhost(127.0.0.1:8000)에서 실행된다고 가정합니다. 어떤 네트웍 인터페이스에서도 동작하도록 하기 위해서는 0.0.0.0:80를 사용합니다.

[[image @///image/en400.png center 306px]]

If you do not provide an administrator password, the administration interface is disabled. This is a security measure to prevent publicly exposing the admin interface.
관리자 암호를 설정하지 않으면 관리자 인터페이스는 비활성화됩니다. 이것은 관리자 인터페이스를 공개적으로 노출시킴으로써 발생하는 보안 이슈를 막기위합입니다.

The administrative interface, **admin**, is only accessible from localhost unless you run web2py behind Apache with mod_proxy. If **admin** detects a proxy, the session cookie is set to secure and **admin** login does not work unless the communication between the client and the proxy goes over HTTPS; this is a security measure. All communications between the client and **admin** must always be local or encrypted; otherwise an attacker would be able to perform a man-in-the middle attack or a replay attack and execute arbitrary code on the server.
관리 인터페이스 **admin**는 Apache mod_proxy를 통해 web2py를 실행하는 경우를 제외하고 localhost에서만 접근 가능합니다. 만약에 **admin**에서 proxy를 감지하는 경우 session 쿠키는 secure로 설정되고 클라이언트와 프락시가 HTTPS를 통하지 않는 경우 **admin** 로긴은 동작하지 않습니다. 

After the administration password has been set, web2py starts up the web browser at the page:
관리자 암호가 설정된 이후 web2py는 web browser를 시작하고 첫화면을 표시합니다.
``
http://127.0.0.1:8000/
``:code

If the computer does not have a default browser, open a web browser and enter the URL.
컴퓨터에 기본 브라우저가 없는 경우에는 원하는 브라우저를 실행하고 URL을 입력합니다.

[[image @///image/en500.png center 480px]]

Clicking on "administrative interface" takes you to the login page for the administration interface.
"administrative interface"를 클릭하면 관리자 인터페이스를 위한 로긴 페이지로 이동합니다.

[[image @///image/en600.png center 480px]]

The administrator password is the password you chose at startup.
Notice that there is only one administrator, and therefore only one administrator password. For security reasons, the developer is asked to choose a new password every time web2py starts unless the <recycle> option is specified. This is distinct from the authentication mechanism in web2py applications.
관리자 암호는 시작시 설정한 암호입니다.
관리자는 오직 한명만 존재한다는 것을 명심해야 합니다. 그래서 관리자 암호도 한개입니다. 보안을 위해서 web2py를 실행할때마다 새로운 암호를 물어보며, <recycle> 옵션을 설정하는 경우 더 이상 물어보지 않습니다. 이것은 web2py application의 인증 메커니즘과는 구분되는 것입니다.

After the administrator logs into web2py, the browser is redirected to the "site" page.
관리자가 web2py에 로그인한 이후 브라우저는 "site" 페이지로 리다이렉트됩니다.

[[image @///image/en700.png center 480px]]

This page lists all installed web2py applications and allows the administrator to manage them.
web2py comes with three applications:
이 페이지에서는 설치된 모든 web2py 어플리케이션들의 목록을 표시하고 관리할 수 있도록 해줍니다.
web2py에는 3개의 어플리케이션이 기본적으로 존재합니다.
``admin``:inxx ``examples``:inxx ``welcome``:inxx ``scaffolding``:inxx
- An **admin** application, the one you are using right now.
- An **examples** application, with the online interactive documentation and a replica of the web2py official website.
- A **welcome** application. This is the basic template for any other web2py application. It is referred to as the scaffolding application. This is also the application that welcomes a user at startup.
- **amdin** 어플리케이션, 지금 사용하고 있는 것
- **examples** 어플리케이션, 온라인 인터렉티브 문서, web2py공식 웹사이트의 사본
- **welcome** 어플리케이션, 다른 web2py 어플리케이션의 기본 템플릿에 해당하며 뼈대 어플리케이션이라고도 한다. 또한 시작시 사용자가 처음 접하는 어플리케이션입니다.

``appliances``:inxx
Ready-to-use web2py applications are referred to as web2py ''appliances''.  You can download many freely available appliances from ``appliances``:cite . web2py users are encouraged to submit new appliances, either in open-source or closed-source (compiled and packed) form.
바로 사용할 수 있는 web2py 어플리케이션을 web2py "appliances"라고 합니다. ``appliances``:cite 에서 자유롭게 다운로드 할 수 있습니다. web2py 유저가  공개소스 형태든 비공개 소스형태로든 새로운 어플리케이션을 제공하도록 유도합니다.

From the **admin** application's ''site'' page, you can perform the following operations:
**admin** 어플리케이션의 "site" 페이지에서는 다음과 같은 작업을 할 수 있습니다.
- **install** an application by completing the form on the bottom right of the page. Give a name to the application, select the file containing a packaged application or the URL where the application is located, and click "submit".
- **uninstall** an application by clicking the corresponding button. There is a confirmation page.
- **create** a new application by choosing a name and clicking "create".
- **package** an application for distribution by clicking on the corresponding button. A downloaded application is a tar file containing everything, including the database. You should not untar this file; it is automatically unpackaged by web2py when installed with **admin**.
- **clean up** an application's temporary files, such as sessions, errors and cache files.
- **EDIT** an application.
- **install** 페이지의 오른쪽 아래에 있는 폼을 완료하여 어플리케이션을 설치합니다. 어플리케이션의 이름을 지정하고, 패키지된 어플리케이션을 포함한 파일을 선택하거나 어플리케이션이 존재하는URL을 입력하고 "submit"을 클릭합니다. 
- **uninstall** uninstall 버튼을 클릭해서 언인스톨 하며 확인 페이지가 있습니다.
- **create** 이름을 정하고 "create"을 클릭해서 새로운 어플리케이션을 생성합니다.
- **package** 패키지 버튼을 클릭해서 배포를 위한 어플리케이션을 패키징합니다. 다운로드 받은 어플리케이션 파일은 database등 어플리케이션에 필요한 모든것이 포함된 tar파일입니다. 이파일은 untar하면 안됩니다. **admin** 에서 인스톨할때 web2py에 의해서 자동으로 해제됩니다.
- **clean up** 어플리케이션의 임시파일들 예를 들어 세션파일, 에러파일, 캐쉬파일들을 삭제합니다.
- **EDIT** 어플리케이션을 편집합니다.


-----
When you create a new application using **admin**, it starts as a clone of the "welcome" scaffolding app with a "models/db.py" that creates a SQLite database, connects to it, instantiates Auth, Crud and Service, configures them. It also provides a "controller/default.py" which exposes actions "index", "download", "user" for user management, and "call" for services. In the following, we assume that these files have been removed; we will be creating apps from scratch.
-----
-----
**admin**을 이용해서 새로운 어플리케이션을 생성할때는 "welcome" 어플리케이션을 복사하는 것부터 시작합니다. 여기에 포함된 "models/db.py"파일은 SQLite 데이터베이스를 생성, 연결하고 Auth, Crud, 서비스 객체를 생성하고 초기화 합니다. "controller/default.py"는 "index", "download", "user"를 제공하며 사용자 관리, 서비스들을 위한 "call" 함수를 제공합니다. 이후에는 이런 파일들이 삭제되었다고 생각하고 처음부터 새로운 어플리케이션을 생성해 볼 것입니다.
-----


-----
web2py also comes with a **wizard**, described later in this chapter, that can write an alternate scaffolding code for you based on layouts and plugins available on the web and based on high level description of the models.
-----
-----
또한 web2py에는 **wizard**가 포함되어 있는데 이후에 설명합니다. wizard는 웹상에 존재하는 레이아웃이나 플러그인, 그리고 상위수준의 model 명세를 기반으로 기본 코드를 생성할 수 있습니다.
-----


### Say hello
``index``:inxx

Here, as an example, we create a simple web app that displays the message "Hello from MyApp" to the user. We will call this application "myapp". We will also add a counter that counts how many times the same user visits the page.
예로 간단하게 "Hello from MyApp" 메세지를 사용자에게 표시하는 어플리케이션을 생성합니다. 이름을 "myapp"이라고 하고 각 사용자들이 얼마나 많이 페이지를 이 페이지를 방문했는지 알수 있는 카운터를 추가할 것입니다.

You can create a new application simply by typing its name in the form on the top right of the **site** page in **admin**.
**admin**에 **site** 페이지의 오른쪽 위쪽에 어플리케이션 이름을 입력해서 새로운 어플리케이션을 생성할 수 있습니다.

[[image @///image/en800.png center 447px]]

After you press [create], the application is created as a copy of the built-in welcome application.
[create]을 누르면 "welcome" 어플리케이션을 복사한 새로운 어플리케이션이 생성됩니다.

[[image @///image/en900.png center 480px]]

To run the new application, visit:
어플리케이션을 실행하기 위해서는 다음에 접속합니다.
``
http://127.0.0.1:8000/myapp
``:code

Now you have a copy of the welcome application.
이제 "welcome" 어플리케이션의 복사본을 만들었습니다.


To edit an application, click on the ''edit'' button for the newly created application.
어플리케이션을 수정하기 위해서는 새로 생성된 어플리케이션의 ''edit''버튼을 클릭합니다.


The **edit** page tells you what is inside the application.
Every web2py application consists of certain files, most of which fall into one of six categories:
**edit**페이지는 어플리케이션에 어떤것이있는지 알려줍니다.
모든 web2py 어플리케이션은 특정파일들로 구성됩니다. 이 파일들은 대부분 아래 6가지 범주에 속합니다.
- **models**: describe the data representation.
- **controllers**: describe the application logic and workflow.
- **views**: describe the data presentation.
- **languages**: describe how to translate the application presentation to other languages.
- **modules**: Python modules that belong to the application.
- **static files**: static images, CSS  files``css:w,css:o,css:school``:cite , JavaScript files``js:w,js:b``:cite , etc.
- **plugins**: groups of files designed to work together.
- **models**: 데이터의 구조를 표현합니다.
- **controllers**: 어플리케이션의 로직과 흐름을 기술합니다.
- **views**: 데이터 표시방법을 기술합니다.
- **languages**: 어플리케이션의 표시를 다른 언어로 어떻게 표시하는지를 설명합니다.
- **modules**: 어플리케이션에 속한 python 모듈이 위치합니다.
- **static files**: 정적인 이미지나, CSS 파일 ``css:w,css:o,css:school``:cite, 자바스크립트 파일``js:w,js:b``:cite, 기타 파일들이 위치합니다.
- **plugins**: 함께 동작하는 하나의 그룹에 속하는 파일들이 위치합니다.

 
Everything is neatly organized following the Model-View-Controller design pattern. Each section in the ''edit'' page corresponds to a subfolder in the application folder.
모든 것은 Model-View-Controller 디자인 패턴을 따라 깔끔하게 구성됩니다. ''edit'' 페이지에 각 섹션은 어플리케이션의 서브 폴더에 대응됩니다.


Notice that section headings will toggle their content. Folder names under static files are also collapsible.
섹션의 헤딩은 각 섹션의 컨텐트로 변경되다는것에 주목하세요. 정적파일 밑에 폴더 이름들은 모두 접을수 있습니다. 

-------
Each file listed in the section corresponds to a file physically located in the subfolder. Any operation performed on a file via the **admin** interface (create, edit, delete) can be performed directly from the shell using your favorite editor.
-------
-------
섹션에 표시되는 각각의 파일 목록은 물리적으로 서브폴더에 위치한 파일에 대응됩니다. ""admin** 인터페이스를 통해서 파일에 수행한 어떤 동작도 자신이 좋아하는 에디터를 이용해서 셀에서 바로 수행할 수 있습니다.
-------



The application contains other types of files (database, session files, error files, etc.), but they are not listed on the ''edit'' page because they are not created or modified by the administrator; they are created and modified by the application itself.
어플리케이션은 여러타입의 파일을 포함하고 있습니다(데이터베이스,세션파일, 에러파일 등). 하지만 edit페이지에는 표시되지 않는데 이파일들은 관리자에의해서 생성되거나 수정되는 것들이 아니기 때문입니다. 이 파일들은 어플리케이션에 의해서 생성되거나 수정됩니다.

The controllers contain the logic and workflow of the application. Every URL gets mapped into a call to one of the functions in the controllers (actions). There are two default controllers: "appadmin.py" and "default.py". **appadmin** provides the database administrative interface; we do not need it now. "default.py" is the controller that you need to edit, the one that is called by default when no controller is specified in the URL. Edit the "index" function as follows:
controller는 어플리케이션은 로직과 처리흐름을 가지고 있습니다. 모든 URL은 컨트롤러내의 한 함수 호출(action)로 매치됩니다. 기본적으로 "appadmin.py" 와 "default.py" 2개의 controller가 있습니다. **appadmin**은 데이터베이스 관리 인터페이스를 제공하지만 현재는 필요하지는 않습니다. "default.py"는 여러분이 수정해야할 controller입니다. 여기에는 URL에 지정된 controller가 존재하지 않는 경우에 호출됩니다. "index"함수를 다음과 같이 수정합니다. 
``
def index():
    return "Hello from MyApp"
``:code

Here is what the online editor looks like:
온라인 에디터에서 수정할때 모습입니다. 

[[image @///image/en1000.png center 480px]]

Save it and go back to the ''edit'' page. Click on the index link to visit the newly created page.
저장하고 다시 ''edit'' 페이지로 이동합니다. 새로 생성된 페이지에 방문하기 위해서는 index 링크를 클릭합니다. 

When you visit the URL
다음 URL을 방문하면
``
http://127.0.0.1:8000/myapp/default/index
``:code

the index action in the default controller of the myapp application is called. It returns a string that the browser displays for us. It should look like this:
myapp 어플리케이션의 기본 controller의 index action이 호출됩니다. 이 함수는 string을 리턴하고 브라우저에서 다음과 같이 표시됩니다.

[[image @///image/en1100.png center 480px]]

Now, edit the "index" function as follows:
이제 "index"함수를 다음과 같이 수정합니다.
``
def index():
    return dict(message="Hello from MyApp")
``:code

Also from the ''edit'' page, edit the view "default/index.html" (the view file associated with the action) and completely replace the existing contents of that file with the following:
''edit'' 페이지에서 "default/indx.html" view 를 수정합니다. 이 파일은 action과 연관된 view 파일입니다. 그이후 이 파일의 내용을 다음의 내용으로 완전히 교체합니다. 

``
<html>
   <head></head>
   <body>
      <h1>{{=message}}</h1>
   </body>
</html>
``:code

Now the action returns a dictionary defining a ``message``. When an action returns a dictionary, web2py looks for a view with the name
이제 action에서는 ``message``를 포함한 딕셔너리를 리턴한다. action이 dictionary를 리턴하는 경우 web2py는 view에서 dictionary에 포함된 name이 있는지 검색한다. 

``[controller]/[function].[extension]``:code

 and executes it. Here [extension] is the requested extension. If no extension is specified, it defaults to "html", and that is what we will assume here. Under this assumption, the view is an HTML file that embeds Python code using special {{ }} tags. In particular, in the example, the ``{{=message}}`` instructs web2py to replace the tagged code with the value of the ``message`` returned by the action. Notice that ``message`` here is not a web2py keyword but is defined in the action. So far we have not used any web2py keywords.
그리고 실행한다. 여기서 [extension]은 요청한 확장자입니다. 확장자가 지정되어 있지 않는 경우 "html"로 설정되고 이 경우에도 그러합니다. 이 가정하에 view는 HTML파일이고 여기에는 특별한 의미를 갖는 {{ }} 태그를 갖는 Python코드를 포함하고 있습니다. 예제에서 ``{{=message}}``은 web2py에게 tagged된 코드를 action에서 리턴한 ``message``의 값으로 변경하도록 알려줍니다. 여기서 ``message``가 web2py의 예약어가 아니고 action에서 정의한 것이 중요합니다. 지금까지 어떤 web2py 예약어도 사용하지 않았습니다.  

If web2py does not find the requested view, it uses the "generic.html" view that comes with every application.
만약에 web2py에서 요청한 view를 찾지 못한 경우에 "generic.html"을 사용하게되며 이 파일은 모든 어플리케이션에 포함되어 있습니다. 

-------
``Mac Mail``:inxx ``Google Maps``:inxx ``jsonp``:inxx
If an extension other than "html" is specified ("json" for example), and the view file "[controller]/[function].json" is not found, web2py looks for the view "generic.json". web2py comes with generic.html, generic.json, generic.jsonp, generic.xml, generic.rss, generic.ics (for Mac Mail Calendar), generic.map (for embedding Google Maps), and generic.pdf (based on fpdf). These generic views can be modified for each application individually, and additional views can be added easily.
-------
-------
만약에 확장자가 "html"이 아닌 다른것이(예를 들어 "json") 지정되고 "[controller]/[function].json" view 파일이 존재하지 않는 경우에 web2py는 "generic.json"파일을 찾게됩니다. web2py는 generic.html, generic.json, generic.jsonp, generic.xml, generic.rss, generic.ics(Mac 메일 달력), generic.map(Google Maps를 임베딩하는 용도), generic.pdf(fpdf 기반)를 포함하고 있습니다. 이 generic view들은 각 어플리케이션을 위해서 각각 변경할 수 있고 또한 추가적인 view 파일들을 쉽게 추가할 수있습니다. 
-------

-------
Generic views are a development tool. In production every action should have its own view. In fact, by default, generic views are only enabled from localhost.
-------
-------
Generic view 파일들은 개발 툴입니다. 실제 제품에서 모든 action은 이게 해당하는 view를 가져야 합니다. 사실 generic view 파일들은 localhost에서만 사용하도록 되어 있습니다.
-------

-------
You can also specify a view with ``response.view = 'default/something.html'``
-------
-------
``response.view = 'default/something.html'``와 같이 view를 지정할 수 있습니다.
-------

Read more on this topic in Chapter 10.
더 자세한 내용은 10장을 참고하세요.
If you go back to "EDIT" and click on index, you will now see the following HTML page:
다시 "EDIT"로 가서 index를 클릭하면 다음과 같은 HTML 페이지를 볼 수 있습니다.
[[image @///image/en1200.png center 480px]]

For debugging purposes you can always append
디버깅을 위해서 다음과 같은 코드를 view에 추가할 수 있습니다.
``
{{=response.toolbar()}}
``:code

to the code in a view and it will show you some useful information, including the request, response and session objects, and list all db queries with their timing.
그러면 view에서 여러가지 유용한 정보를 보여줍니다. request, response, session 오브젝트, 시간 정보를 포함한 모든db 쿼리들을 포함하고 있습니다.

### Let's count
### 세어보아요
``session``:inxx
Let's now add a counter to this page that will count how many times the same visitor displays the page.
이제 이 페이지에 카운터를 추가합니다. 이 카운트는 같은 사용자가 얼마나 많이 페이지를 방문했는지에 대해 계산할 것입니다.
web2py automatically and transparently tracks visitors using sessions and cookies. For each new visitor, it creates a session and assigns a unique "session_id". The session is a container for variables that are stored server-side. The unique id is sent to the browser via a cookie. When the visitor requests another page from the same application, the browser sends the cookie back, it is retrieved by web2py, and the corresponding session is restored.
web2py는 자동으로 그리고 투명하게 세션과 쿠키를 이용해서 방문자를 추적합니다. 새로운 방문자마다 새로운 새션을 생성하고 유일한 "session_id"를 할당합니다. 세션은 서버측에 저장되는 변수를 담는 컨테이너입니다. 유일한 id는 쿠키를 통해서 브라우저로 전송됩니다. 방문자가 같은 어플리케이션의 다른 페이지를 요청할때 브라우저가 쿠키를 다시 서버로 전송하게되고 web2py에서 유일한 id값을 얻게 됩니다. 이 값에 해당하는 session이 복구됩니다.

To use the session, modify the default controller:
세션을 사용하기 위해서는 기본 controller를 수정합니다.
``
def index():
    if not session.counter:
        session.counter = 1
    else:
        session.counter += 1
    return dict(message="Hello from MyApp", counter=session.counter)
``:code

Notice that ``counter`` is not a web2py keyword but ``session`` is. We are asking web2py to check whether there is a counter variable in the session and, if not, to create one and set it to 1. If the counter is there, we ask web2py to increase the counter by 1. Finally we pass the value of the counter to the view.
``counter``는 web2py 예약어가 아니지만 ``session``는 예약어라는 것을 주목하세요. 우리는 web2py에게 session에 counter 변수가 포함되어 있는지검사하도록 지시합니다. 만약에 존재하지 않는 다음 하나를 생성하고 1로 설정합니다. 만약에 counter 변수가 존재한다면 값을 1증가하도록 web2py에 요청합니다. 마지막으로 counter의 값을 view에 전달합니다.

A more compact way to code the same function is this:
같은 함수를 더 깔끔하게 코딩하면 다음과 같습니다. 
``
def index():
    session.counter = (session.counter or 0) + 1
    return dict(message="Hello from MyApp", counter=session.counter)
``:code

Now modify the view to add a line that displays the value of the counter:
이제 counter값을 표시할 한줄을 view에 추가합니다.
``
<html>
   <head></head>
   <body>
      <h1>{{=message}}</h1>
      <h2>Number of visits: {{=counter}}</h2>
   </body>
</html>
``:code

When you visit the index page again (and again) you should get the following HTML page:
다시 index 페이지를 방문할때 다음과 같은 HTML 페이지를 보게될 것입니다.
[[image @///image/en1300.png center 480px]]

The counter is associated with each visitor, and is incremented each time the visitor reloads the page. Different visitors see different counters.
counter는 각 방문자와 연관되어 있고 페이지를 리로딩할때마다 증가합니다. 다른 방문자들은 각각 다른 counter 값을 보게 됩니다.
### Say my name
### 내 이름을 말해봐
``form``:inxx ``request.vars``:inxx

Now create two pages (first and second), where the first page creates a form, asks the visitor's name, and redirects to the second page, which greets the visitor by name.
이제 2페이지(첫번재와 두번째)를 생성합니다. 첫번째 페이지에서는 하나의 form을 생성하고 방문자에게 이름을 물어봅니다. 그리고 두번째 페이지로 리다이렉트합니다. 두번째 페이지에서는 방문자의 이름로 반갑게 맞아 줍니다.

[[yUML diagram @///image/en1400.png center 293px]]

Write the corresponding actions in the default controller:
다음 기본 controller에서 그에 해당하는 action을 작성합니다.
``
def first():
    return dict()

def second():
    return dict()
``:code

Then create a view "default/first.html" for the first action,
그다음 첫번째 action에 대한 "default/first.html"을 생성합니다.
and enter:
그리고 다음과 같이 입력합니다.
``
{{extend 'layout.html'}}
What is your name?
<form action="second">
  <input name="visitor_name" />
  <input type="submit" />
</form>
``:code

Finally, create a view "default/second.html" for the second action:
끝으로 두번째 action을 위한 "default/second.html" view를 생성합니다.
``
{{extend 'layout.html'}}
<h1>Hello {{=request.vars.visitor_name}}</h1>
``:code

``layout``:inxx
In both views we have extended the basic "layout.html" view that comes with web2py. The layout view keeps the look and feel of the two pages coherent. The layout file can be edited and replaced easily, since it mainly contains HTML code.
두개의 view파일 모두 web2py에 포함된 "layout.html" view를 확장합니다. 이 layout view는 생성된 2개의 페이지의 룩앤필을 일관성있게 유지해 줍니다.
If you now visit the first page, type your name:
첫번째 페이지에 방문해서 이름을 입력하고
[[image @///image/en1500.png center 480px]]

and submit the form, you will receive a greeting:
form을 제출하면 환영 메세지를 받을 것입니다.
[[image @///image/en1600.png center 480px]]

### Postbacks
### Postbacks
``redirect``:inxx ``URL``:inxx ``postback``:inxx

The mechanism for form submission that we used before is very common, but it is not good programming practice. All input should be validated and, in the above example, the burden of validation would fall on the second action. Thus the action that performs the validation is different from the action that generated the form. This tends to cause redundancy in the code.
위에서 사용한 form 제출 메커니즘은 매우 일반적인 것입니다. 그러나 좋은 프로그래밍 관행은 아닙니다. 모든 입력에 대해서는 유효성 검사를 해야 하고 위의 예제의 경우 유효성 검사에 대한 부담을 두번째 페이지에서 지게됩니다. 그래서 유효성을 검사하는 action과 form을 생성했던 action과 다릅니다. 이것은 불필요한 코드를 만들 개연성이 큽니다.

A better pattern for form submission is to submit forms to the same action that generated them, in our example the "first". The "first" action should receive the variables, process them, store them server-side, and redirect the visitor to the "second" page, which retrieves the variables. This mechanism is called a ''postback''.
form 제출에 대한 더 나은 패턴은 form을 생성했던 action에 다시 form을 제출하는 것입니다. 우리 예제의 경우 "첫번째" 페이지가 됩니다. "첫번째" action은 모든 변수를 받고 처리하고 서버측에 저장하고 다시 사용자를 "두번째"페이지로 리다이렉트합니다. 이 두번째 페이지에서는 전달된 모든 변수를 받게됩니다. 이러한 메커니즘을 "postback"이라고 부릅니다.

[[yUML diagram @///image/en1700.png center 293px]]

Modify the default controller to implement self-submission:
자기제출(self-submission)을 구현하기 위해서 기본 controller를 수정합니다.
``
def first():
    if request.vars.visitor_name:
        session.visitor_name = request.vars.visitor_name
        redirect(URL('second'))
    return dict()

def second():
    return dict()
``:code

Then modify the "default/first.html" view:
그다음 "default/first.html" view를 수정합니다.
``
{{extend 'layout.html'}}
What is your name?
<form>
  <input name="visitor_name" />
  <input type="submit" />
</form>
``:code

and the "default/second.html" view needs to retrieve the data from the ``session`` instead of from the ``request.vars``:
그리고 "default/second.html" view는 데이터를 ``request.vars``로 부터 얻는 대신 ``session``에서 얻도록 해야 합니다.
``
{{extend 'layout.html'}}
<h1>Hello {{=session.visitor_name or "anonymous"}}</h1>
``:code

From the point of view of the visitor, the self-submission behaves exactly the same as the previous implementation. We have not added validation yet, but it is now clear that validation should be performed by the first action.
방문자의 관점에서 보면 자기제출(self-submission)의 동작은 이전 구현과 정확히 일치합니다. 아직 유효검사를 추가하지는 않았지만 이제 유효성검사가 첫번째 action에서 수행되어야 한다는것은 명확합니다.

This approach is better also because the name of the visitor stays in the session, and can be accessed by all actions and views in the applications without having to be passed around explicitly.
이 시도는 방문자의 이름이 session에 저장되어 있기 때문에 더 낫습니다. 또한 명시적으로 전달될 필요 없이 어플리케이션의 모든 action과 view에서 접근가능하게 됩니다.

Note that if the "second" action is ever called before a visitor name is set, it will display "Hello anonymous" because  ``session.visitor_name`` returns ``None``. Alternatively we could have added the following code in the controller (inside the ``second`` function):
만약에 "second" action이 방문자의 이름이 설정되기 전에 호출되는 경우에 "Hello anonymous"를 표시합니다. 왜냐하면 ``session.visitor_name``은 ``None``을 리턴하기 때문입니다. 대안으로는 다음 코드를 controller의 ``second`` function안에 추가할 수 있습니다.

``
if not request.function=='first' and not session.visitor_name:
    redirect(URL('first'))
``:code

This is a general mechanism that you can use to enforce authorization on controllers, though see Chapter 9 for a more powerful method.
이것은 controller에서 인증을 요구할수 있는 일반적인 매커니즘입니다. 더 좋은 방법에 대해서 9장에서 보게 될 것입니다.

``FORM``:inxx ``INPUT``:inxx ``requires``:inxx ``IS_NOT_EMPTY``:inxx ``accepts``:inxx

With web2py we can move one step further and ask web2py to generate the form for us, including validation. web2py provides helpers (FORM, INPUT, TEXTAREA, and SELECT/OPTION) with the same names as the equivalent HTML tags. They can be used to build forms either in the controller or in the view.
한발짝 더 나아가 web2py에게 유효성 검사를 포함한 form을 생성하도록 할 수 있습니다. web2py는 HTML 태크와 일치하는 FORM, INPUT, TEXTAREA, SELECT/OPTION 헬퍼를 제공합니다. 이 헬퍼는 controller나 view에서 form을 생성하는데 사용될 수 있습니다.

For example, here is one possible way to rewrite the first action:
예를 들어 다음은 "first" action을 다시 작성할 수 있는 한가지 방법입니다.
``
def first():
    form = FORM(INPUT(_name='visitor_name', requires=IS_NOT_EMPTY()),
              INPUT(_type='submit'))
    if form.process().accepted:
        session.visitor_name = form.vars.visitor_name
        redirect(URL('second'))
    return dict(form=form)
``:code

where we are saying that the FORM tag contains two INPUT tags. The attributes of the input tags are specified by the named arguments starting with underscore. The ``requires`` argument is not a tag attribute (because it does not start by underscore) but it sets a validator for the value of visitor_name.
FORM 태크는 두개의 INPUT 태크를포함하고 있습니다. input 태크의 속성들은 _(underscore)로 시작하는 명명된 인수로 지정됩니다. ``requires`` 인수는 태그의 속성이 아니고(왜냐하면 이것은 _(underscore)로 시작하지 않기 때문입니다.) "visitor_name"의 값에 대한 유효검사자를 설정합니다.
Here is yet another better way to create the same form:
다음은 같은 form을 생성하는 더 나은 방법입니다.
``
def first():
    form = SQLFORM.factory(Field('visitor_name', requires=IS_NOT_EMPTY()))
    if form.process().accepted:
        session.visitor_name = form.vars.visitor_name
        redirect(URL('second'))
    return dict(form=form)
``:code

The ``form`` object can be easily serialized in HTML by embedding it in the "default/first.html" view.
``form`` 오브젝트는 "default/first.html" view안에 포함시키므로써 쉽게 HTML안에 직렬화 할 수 있습니다.
``
{{extend 'layout.html'}}
What is your name?
{{=form}}
``:code

The ``form.process()`` method applies the validators and returns the form itself. The ``form.accepted`` variable is set to True if the form was processed and passed validation. If the self-submitted form passes validation, it stores the variables in the session and redirects as before. If the form does not pass validation, error messages are inserted into the form and shown to the user, as below:
``form.process()`` 메소드는 유효검사자를 적용하고 form자체를 리턴합니다. ``form.accepted`` 변수는 form이 처리되고 유효성검사를 통과하면 True로 설정됩니다. 자기제출(self-submitted)된 form이 유효성 검사를 통과하는 경우 세션에 변수들을 저장하고 이전으로 리다이렉트합니다. form이 유효성검사를 통과하지 못하는 경우 에러 메세지가 form에 삽입되고 사용자에게 다음과 같이 보여집니다.
[[image @///image/en1800.png center 480px]]

In the next section we will show how forms can be generated automatically from a model.
다음 섹션에서는 어떻게 model에서 자동으로 form이 생성되는지 보게 될 것입니다.
### An image blog
### 이미지 블로그
``upload``:inxx

Here, as another example, we wish to create a web application that allows the administrator to post images and give them a name, and allows the visitors of the web site to view the named images and submit comments.
이번 예제에서는 관리자가 이미지를 포스트하고 이미지에 이름을 설정하고 방문자에게 이름이 주어진 이미지를 보게하고 코멘트를 달도록 하는 어플리케이션을 생성할 것입니다.
As before, from the **site** page in **admin**, create a new application called ``images``, and navigate to the ''edit'' page:
이전처럼 **admin** 페이지의 **site** 페이지에서 ``image``라는 새로운 어플리케이션을 생성합니다. 그 다음 ''edit'' 페이지로 이동합니다.
[[image @///image/en1900.png center 480px]]

We start by creating a model, a representation of the persistent data in the application (the images to upload, their names, and the comments). First, you need to create/edit a model file which, for lack of imagination, we call "db.py". We assume the code below will replace any existing code in "db.py". Models and controllers must have a ``.py`` extension since they are Python code. If the extension is not provided, it is appended by web2py. Views instead have a ``.html`` extension since they mainly contain HTML code.
하나의 모델과 영구 데이터(업로드한 이미지들, 이미지에 대한 이름, 코멘트)에 대한 표현계층을 생성하는 것으로 시작합니다. 첫번째 하나의 model 파일을 생성하고 수정합니다. 이 파일을 "db.py"라고 부릅니다.(상상력이 부족해서 그냥 그렇게 부르겠습니다.)  아래 코드로 "db.py"파일을 교체한다고 가정합니다. Model과 controller는 ``.py`` 확장자를 가져야 합니다. 왜냐하면 이 파일들은 Python 코드이기 때문입니다. 만약 확장자가 주어지지 않는다면 web2py에 의해서 추가될 것입니다. 대신에 View는 ``html``확장자를 갖는데 이것은 대부분 HTML code를 포함하기 때문입니다.

Edit the "db.py" file by clicking the corresponding "edit" button:
"edit" 버튼을 클릭해서 "db.py"파일을 수정합니다.
[[image @///image/en2000.png center 480px]]

and enter the following:
그리고 다음과 같이 입력합니다.

``IS_EMAIL``:inxx ``IS_NOT_EMPTY``:inxx ``IS_IN_DB``:inxx
``
db = DAL("sqlite://storage.sqlite")

db.define_table('image',
   Field('title', unique=True),
   Field('file', 'upload'),
   format = '%(title)s')

db.define_table('comment',
   Field('image_id', 'reference image'),
   Field('author'),
   Field('email'),
   Field('body', 'text'))

db.image.title.requires = IS_NOT_IN_DB(db, db.image.title)
db.comment.image_id.requires = IS_IN_DB(db, db.image.id, '%(title)s')
db.comment.author.requires = IS_NOT_EMPTY()
db.comment.email.requires = IS_EMAIL()
db.comment.body.requires = IS_NOT_EMPTY()

db.comment.image_id.writable = db.comment.image_id.readable = False
``:code

Let's analyze this line by line.
한줄한줄 살펴보도록 하죠.
Line 1 defines a global variable called ``db`` that represents the database connection. In this case it is a connection to a SQLite database stored in the file  "applications/images/databases/storage.sqlite". In the SQLite case, if the database does not exist, it is created. You can change the name of the file, as well as the name of the global variable ``db``, but it is convenient to give them the same name, to make it easy to remember.
1라인은 ``db``라는 전역 변수를 정의합니다. 이것은 데이터 베이스 연결을 나타냅니다. 이 경우 SQLite 데이터베이스에 대한 연결이고 "applications/images/databases/storage.sqlite" 파일에 저장됩니다. SQLite 의 경우 데이터베이스가 존재하지 않는 경우 생성됩니다. 이 파일에 이름을 수정할 수 있으며 전역변수 ``db`` 의 이름도 수정할 수 있습니다. 하지만 관례상 같은 이름이 주어지고 기억하기 쉽도록 도와줍니다.
Lines 3-5 define a table "image". ``define_table`` is a method of the ``db`` object. The first argument, "image", is the name of the table we are defining. The other arguments are the fields belonging to that table. This table has a field called "title", a field called "file", and a field called "id" that serves as the table primary key ("id" is not explicitly declared because all tables have an id field by default). The field "title" is a string, and the field "file" is of type "upload". "upload" is a special type of field used by the web2py Data Abstraction Layer (DAL) to store the names of uploaded files. web2py knows how to upload files (via streaming if they are large), rename them safely, and store them.
3-5라인은 "image" 테이블을 정의합니다. ``define_table``은 ``db`` 오브젝트의 메소드 입니다. 첫번째 인수 "image"는 우리가 정의한 테이블의 이름입니다. 다른 인수들은 테이블에 속한 필드들입니다. 이 테이블은 "title", "file", "id"라는 필드를 가지고 있고 "id" 필드는 테이블의 기본키로 동작합니다.(모든 테이블은 기본적으로 "id" 필드를 가지고 있기 때문에 "id"는 명시적으로 선언되지 않습니다.)."title" 필드는 스트링이며 "file"는 "upload" 타입입니다. "upload"는 특별한 필드로 web2py Data Abstraction Layer(DAL)에서 업로드한 파일들의 이름을 저장하는 용도로 사용됩니다. web2py는 어떻게 파일들을 업로드하고(큰경우 스트리밍을 통해서), 안전하게 이름을 변경하고 저장합니다.

When a table is defined, web2py takes one of several possible actions:
- if the table does not exist, the table is created;
- if the table exists and does not correspond to the definition, the table is altered accordingly, and if a field has a different type, web2py tries to convert its contents;
- if the table exists and corresponds to the definition, web2py does nothing.
테이블이 정의될때 web2py는 가능한 몇가지 action들에 한가지를 수행합니다.
- 만약에 테이블이 존재하지 않는 경우 테이블을 생성합니다.
-. 테이블이 존재하고 정의와 일치하지 않는 경우 그에 맞게 테이블을 수정하고 필드가 다른 타입인 경우 web2py는 필드의 값변환을 시도 합니다.
-. 테이블의 존재하고 정의와 일치하는 경우 아무것도 하지 않습니다.

This behavior is called "migration". In web2py migrations are automatic, but can be disabled for each table by passing ``migrate=False`` as the last argument of ``define_table``.
이런 동작을 "migration"이라고 부릅니다. web2py 마이그레이션은 자동으로 일어나고 ``define_table``의 마지막 인수로 테이블에 ``migrate=False``를 전달함으로써 각 테이블에서 해제 할 수 있습니다.
Line 6 defines a format string for the table. It determines how a record should be represented as a string. Notice that the ``format`` argument can also be a function that takes a record and returns a string. For example:
5라인은 테이블을 위한 형식화된 문자를 정의합니다. 이것은 어떻게 레코드가 문자열로 표시되어야 하는지를 결정합니다. ``format`` 인수는 함수가 될수 있다는 것을 주목하세요. 이 함수는 레코드를 취할 수 있고 문자열을 반환합니다. 예를 들면 다음과 같습니다.
``
format=lambda row: row.title
``:code

Lines 8-12 define another table called "comment".
A comment has an "author", an "email" (we intend to store the email address of the author of the comment), a "body" of type "text" (we intend to use it to store the actual comment posted by the author), and an "image_id" field of type reference that points to ``db.image`` via the "id" field.
8-12라인은 "comment"라는 테이블 정의합니다.
이 테이블은 "author", "email"을 가지고 있고 "email" 필드는 코멘트 작성자의 email 주소를 저장할 용도로 사용합니다. "text" 형식의 "body" 필드를 가지고 있으며 작성자의 작성한 코멘트 자체를 저장하는 용도로 사용됩니다. "image_id" 필드는 레퍼런스 형식으로 "id" 필드를 통해서 ``db.image`` 테이블을 지정합니다.

In line 14, ``db.image.title`` represents the field "title" of table "image". The attribute ``requires`` allows you to set requirements/constraints that will be enforced by web2py forms. Here we require that the "title" is unique:
라인 14 ``db.image.title``는 "image" 테이블의 "title" 필드를 나타냅니다. ``requires`` 속성은 요구사항이나 제약조건을 설정할 수 있도록 해줍니다. 이런 요구사항이나 제약조건은 web2py form에서 요구하게 됩니다. 여기서는 "title" 필드는 유일 할 것을 요구하는 것입니다.
``IS_NOT_IN_DB(db, db.image.title)``:code

''Notice this is optional because it is set automatically given that ``Field('title', unique=True)``''.
선택사항이라는 것을 주목하세요. 왜나하면 ``Field('title', unique=True)``에서  자동으로 설정됩니다. 
The objects representing these constraints are called validators. Multiple validators can be grouped in a list. Validators are executed in the order they appear.
이런 제약조건을 표현하는 오브젝트들을 유효자라고 합니다. 다수의 유효자는 하나의 리스트로 묶일 수 있습니다. 유효자들은 나타나는 순서대로 실행됩니다.
``IS_NOT_IN_DB(a, b)`` is a special validator that checks that the value of a field ``b`` for a new record is not already in ``a``.
``IS_NOT_IN_DB(a,b)``는 특별한 유효자로 새로운 레코드에 대해서 필드 ``b``값이 ``a``에는 존재하지 않는 것을 검사하는 용도로 사용됩니다.
Line 15 requires that the field "image_id" of table "comment" is in ``db.image.id``. As far as the database is concerned, we had already declared this  when we defined the table "comment".
15라인은 "comment" 테이블의 "image_id" 필드가 ``db.image.id``안에 있는 것을 요구합니다. 데이터베이스에 관해서는 테이블 "comment"를 정의할때 이미 선언하였습니다.
Now we are explicitly telling the model that this condition should be enforced by web2py, too, at the form processing level when a new comment is posted, so that invalid values do not propagate from input forms to the database. We also require that the "image_id" be represented by the "title", ``'%(title)s'``, of the corresponding record.
이제 명시적으로 model에게 이 조건은 코멘트가 포스팅 될때 web2py가 form 처리 단계에서 지켜져야 한다고 명시하고 있습니다. 그래서 유효하지 않는 값의 경우 입력 form에서 데이터베이스로 전파되지 않도록 합니다. "image_id"는 "title"을 해당하는 레코드의 ``%(title)s'``로 표현되어 질것을 요구합니다.
Line 20 indicates that the field "image_id" of table "comment" should not be shown in forms, ``writable=False`` and not even in readonly forms, ``readable=False``.
20라인 ``writable=False``은 "comment" 테이블의 "image_id" 필드가 form에서 보여지지 않아야 하는 것을 가르킵니다. ``readable=False``의 경우 읽기전용 form에서도 표시되지 않도록 합니다.

The meaning of the validators in lines 15-17 should be obvious.
15-17라인의 유효자들의 의미는 자명해야 합니다.
``format``:inxx
Notice that the validator
``
db.comment.image_id.requires = IS_IN_DB(db, db.image.id, '%(title)s')
``:code

can be omitted (and would be automatic) if we specify a format for referenced table:
유효자는 참조되는 테이블의 포맷을 지정한다면 생략할 수 있다는 것에 주목하세요

``
db.define_table('image', ..., format='%(title)s')
``:code

where the format can be a string or a function that takes a record and returns a string.
포맷은 스트링이나 레코드를 인수로 받고 스트링을 리턴하는 함수가 될수 있습니다.
``appadmin``:inxx
Once a model is defined, if there are no errors, web2py creates an application administration interface to manage the database. You access it via the "database administration" link in the ''edit'' page or directly:
에러없이 모델이 정의되고 나면 web2py는 데이터베이서를 관리할 어플리케이션 관리 인터페이스를 생성합니다. "edit"페이지나 직접적으로 "database administration"링크를 통해서 접근 가능합니다.
``
http://127.0.0.1:8000/images/appadmin
``:code

Here is a screenshot of the **appadmin** interface:
다음은 **appadmin** 인터페이스의 스크린샷입니다.
[[image @///image/en2100.png center 480px]]

This interface is coded in the controller called "appadmin.py" and the corresponding view "appadmin.html". From now on, we will refer to this interface simply as **appadmin**. It allows the administrator to insert new database records, edit and delete existing records, browse tables, and perform database joins.
이 인터페이스는 "appadmin.py"라는 controller와 "appadmin.html" view에 작성되어 있습니다. 이제부터 간단히 **appadmin** 로 칭하겠습니다. 이를 통해서 새로운 데이터베이스 레코드를 삽입하고 수정하고 존재하는 레코드를 삭제하고 테이블을 표시하고 데이터베이스 join을 수행합니다.
The first time **appadmin** is accessed, the model is executed and the tables are created. The web2py DAL translates Python code into SQL statements that are specific to the selected database back-end (SQLite in this example). You can see the generated SQL from the ''edit'' page by clicking on the "sql.log" link under "models". Notice that the link is not present until the tables have been created.
처음 **appapdmin**이 사용될때 model이 실행되고 테이블이 생성됩니다. web2py DAL은 Python 코드를 벡엔드 데이터베이스(이번 예제에서는 SQLite)에 맞는 SQL 문으로 변환합니다. "edit"페이지의 "model"아래 "sql.log" 링크를 클릭해서 생성된 SQL을 볼수 있습니다. 이 링크는 테이블이 생성되기 전까지는 존재하지 않습니다.
[[image @///image/en2200.png center 480px]]

If you were to edit the model and access **appadmin** again, web2py would generate SQL to alter the existing tables. The generated SQL is logged into "sql.log".
모델을 수정했고 다시 **appadmin**에 접근했다면 web2py는 존재하는 테이블을 수정하는 SQL문을 생성할 것입니다. 생성된 SQL은 "sql.log"에 로깅됩니다.
Now go back to **appadmin** and try to insert a new image record:
**appadmin** 으로 다시 되돌아가서 새로운 image 레코드를 삽입해 봅니다.
[[image @///image/en2300.png center 480px]]

web2py has translated the ``db.image.file`` "upload" field into an upload form for the file. When the form is submitted and an image file is uploaded, the file is renamed in a secure way that preserves the extension, it is saved with the new name under the application "uploads" folder, and the new name is stored in the ``db.image.file`` field. This process is designed to prevent directory traversal attacks.
web2py는 ``db.image.file`` "upload" 필드를 파일을 위한 upload form으로 변환합니다. form이 제출될때 이미지 파일은 업로드 됩니다. 이 파일의 이름은  안전한 방법으로 변경되며 확장자는 유지됩니다. 이파일은 새로운 이름으로 어플리케이션의 "uploads" 폴더 밑에 저장되고 새로운 이름은 ``db.image.file`` 필드에 저장됩니다. 이러한 처리는 디렉토리 탐색 공격을 막기위해 설계되었습니다.
Notice that each field type is rendered by a ''widget''. Default widgets can be overridden.
각각의 필드 타입은 "widget"에 의해서 표시됩니다. 기본 widget은 override가능합니다.
When you click on a table name in **appadmin**, web2py performs a select of all records on the current table, identified by the DAL query
**appadmin**의 테이블 이름을 클릭할때 web2py는 DAL 쿼리에 의해서 지정된 select를 현재 테이블의 모든 레코드에 수행합니다.
``
db.image.id > 0
``:code

and renders the result.
그후 결과를 표시합니다.

[[image @///image/en2400.png center 480px]]

You can select a different set of records by editing the SQL query and pressing [Submit].
SQL 쿼리를 수정하고 제출하므로써 다른 레코드 셋을 선택할 수 있습니다.
To edit or delete a single record, click on the record id number.
하나의 레코드를 수정 삭제하기 위해서는 레코드 id 숫자를 클릭합니다.

Because of the ``IS_IN_DB`` validator, the reference field "image_id" is rendered by a drop-down menu. The items in the drop-down are stored as keys (``db.image.id``), but are represented by their ``db.image.title``, as specified by the validator.
``IS_IN_DB`` 유효자때문에 참조 필드 "image_id"는 drop-down 메뉴로 표시됩니다. drop-down 의 아이템은 ``db.image.id``의 키로 저장됩니다. 하지만 유효자에서 지정한 ``db.image.title``에 의해서 표시됩니다. 
Validators are powerful objects that know how to represent fields, filter field values, generate errors, and format values extracted from the field.
유효자는 필드를 어떻게 표시하고 값을 필터링하고 에러를 발생시키고 필드에서 추출한 값을 형식에 맞게 표시하는 방법을 알고 있는 강력한 오브젝트입니다.
The following figure shows what happens when you submit a form that does not pass validation:
다음 그림은 유효검사를 통과하지 못한 폼을 제출한 경우 어떤 일이 벌어지는지를 보여줍니다.
[[image @///image/en2500.png center 480px]]

The same forms that are automatically generated by **appadmin** can also be generated programmatically via the ``SQLFORM`` helper and embedded in user applications. These forms are CSS-friendly, and can be customized.
**appadmin**에 의해서 자동으로 생성된 같은 폼은 ``SQLFORM`` 헬퍼을 통해서 프로그래밍 적으로 생성할 수 있으며 사용자 어플리케이션에 포함시킬 수 있습니다. 이런 form들은 CSS에 적합하고 커스터마이징이 가능합니다.
Every application has its own **appadmin**; therefore, **appadmin** itself can be modified without affecting other applications.
모든 어플리케이션은 각자의 **appadmin**을 가지고 있어서 **appadmin** 자체를 다른 어플리케이션에 영향을 주지 않고 변경할 수 있습니다.

So far, the application knows how to store data, and we have seen how to access the database via **appadmin**. Access to **appadmin** is restricted to the administrator, and it is not intended as a production web interface for the application; hence the next part of this walk-through. Specifically we want to create:
지금까지 어플리케이션이 어떻게 데이터를 저장하는지 알고 **appadmin**을 통해서 어떻게 데이터베이스에 접근하는지 봤습니다. **appadmin**에 접근하는 것은 관리자에게만 허용됩니다. 그리고 이것은 어플리케이션의 상용 제품 웹 인터페이스로 의도된 것이 아닙니다. 그래서 다음 파트는 이부분에 대해서 살펴볼 것입니다. 특별히 다음의 것들을 생성하길 원합니다.
- An "index" page that lists all available images sorted by title and links to detail pages for the images.
- A "show/[id]" page that shows the visitor the requested image and allows the visitor to view and post comments.
- A "download/[name]" action to download uploaded images.
- "index" 페이지: 제목으로 정렬된 모든 이미지들을 목록으로 표시하고 이러한 이미지에 대한 자세한 정보를 표시하는 페이지로 링크합니다.
- "show/[id]" 페이지: 요청된 이미지를 방문자에게 보여주고 방문자가 보고 코멘트를 포스트 할 수 있도록 해줍니다.
-. "download/[name]" action: 업로드된 이미지를 다운로드 합니다.

This is represented schematically here:
도식화 화면 다음과 같습니다.
[[yUML diagram @///image/en2600.png center 480px]]

Go back to the ''edit'' page and edit the "default.py" controller, replacing its contents with the following:
"edit" 페이지로 돌아가서 "default.py" controller를 수정합니다. 그리고 내용을 다음과 같이 변경합니다.
``select``:inxx
``
def index():
    images = db().select(db.image.ALL, orderby=db.image.title)
    return dict(images=images)
``:code

This action returns a dictionary. The keys of the items in the dictionary are interpreted as variables passed to the view associated to the action. When developing, if there is no view, the action is rendered by the "generic.html" view that is provided with every web2py application.
이 action은 dictionary를 반환합니다. dictionary의 아이템의 키는 변수로 번역되고 action와 연결된 view에 전달됩니다. 개발할때 view가 없다면 action은 모든 web2py 어플리케이션에 제공되어진 "generic.html" view를 통해서 표시됩니다.

The index action performs a select of all fields (``db.image.ALL``) from table image, ordered by ``db.image.title``. The result of the select is a ``Rows`` object containing the records. Assign it to a local variable called ``images`` returned by the action to the view. ``images`` is iterable and its elements are the selected rows. For each row the columns can be accessed as dictionaries:
``images[0]['title']`` or equivalently as ``images[0].title``.
index action은 이미지 테이블에서 ``db.image.title`` 순으로 모든 필드(``db.image.ALL``)에 select를 수행합니다. select의 결과는 ``Rows`` 오브젝ㄴ트 이며 로케드를 포함하고 있습니다. 지역 변수 ``images``에 지정하고 action에서 view로 전달됩니다. ``images``는 순회가능하고  내부 요소는 선택된 row입니다. 각각의 row에 대해서 컬럼은 dictionary로서 접근 가능합니다.:
``images[0]['title']`` 또는 ``images[0].title``.

If you do not write a view, the dictionary is rendered by "views/generic.html" and a call to the index action would look like this:
view를 작성하지 않는다면 dictionary는 "views/generic.html"에 의해서 표시되고 index action에 대한 호출은 다음과 같을 것입니다.
[[image @///image/en2700.png center 480px]]

You have not created a view for this action yet, so web2py renders the set of records in plain tabular form.
이 action에 대해서 아직 view를 생성하지 않았고 그래서 web2py가 보통 테이블 form으로 레코드 셋을 표시합니다.
Proceed to create a view for the index action. Return to admin, edit "default/index.html" and replace its content with the following:
index action에 대한 view를 생성을 처리하고 admin으로 되돌아 가서 "default/index.html"을 수정하고 이 내용을 다음과 같이 수정합니다.
``
{{extend 'layout.html'}}
<h1>Current Images</h1>
<ul>
{{for image in images:}}
{{=LI(A(image.title, _href=URL("show", args=image.id)))}}
{{pass}}
</ul>
``:code

The first thing to notice is that a view is pure HTML with special {{...}} tags. The code embedded in {{...}} is pure Python code with one caveat: indentation is irrelevant. Blocks of code start with lines ending in colon (:) and end in lines beginning with the keyword ``pass``. In some cases the end of a block is obvious from context and the use of ``pass`` is not required.
가장 처음 보아야 할 것은 view는 순수한 HTML이며 특별한 {{...}} 태크를 갖는다는 것입니다. {{..}}에 포함된 코드는 순수한 Python 코드이며 한가지 단점은 들여쓰기가 무의미 하다는 것입니다. 코드 블럭은 라인의 끝이 colon(:)으로 시작하고 ``pass`` 키워드로 끝납니다. 어떤꼉우 블럭의 끝이 명확해서 ``pass``가 필요 없는 경우도 있습니다.

Lines 5-7 loop over the image rows and for each row image display:
5-7라인의 image rows에 대한 루프를 수행하고 각 row image를 표시합니다.
``
LI(A(image.title, _href=URL('show', args=image.id))
``:code

This is a ``<li>...</li>`` tag that contains an ``<a href="...">...</a>`` tag which contains the ``image.title``. The value of the hypertext reference (href attribute) is:
``<li>...</li>`` 태그는 ``<a href="...">...</a>`` 태그를 포함하고 a 태그는 ``image.title``을 포함합니다. 하이퍼텍스트 (href 속성) 참조 값은 다음과 같습니다.
``
URL('show', args=image.id)
``:code

i.e., the URL within the same application and controller as the current request that calls the function called "show", passing a single argument to the function, ``args=image.id``.
예들 들어 같은 어플리케이션안에 URL과 현재 "show"를 호출하는 controller는 하나의 인수(``args=image.id``)를 함수에 전달하고 있다.
``LI``, ``A``, etc. are web2py helpers that map to the corresponding HTML tags. Their unnamed arguments are interpreted as objects to be serialized and inserted in the tag's innerHTML. Named arguments starting with an underscore (for example ``_href``) are interpreted as tag attributes but without the underscore. For example ``_href`` is the ``href`` attribute, ``_class`` is the ``class`` attribute, etc.
``LI``, ``A`` 등은 web2py 헬퍼로써 그에 상응하는 HTML 태그로 매핑됩니다. 이름이 없는 인수의 경우 직렬화 된느 오브젝트로 번역되고 태그의 innterHTML안에 삽입됩니다. 명명된 인수의 경우 underscore(예들 들면 ``_href``)로 시작하고 태그의 속성으로 해석되고 underscore('_')는 제거됩니다. 예를 들어 ``_href``는 ``href`` 속성이 되고 ``_class``는 ``class`` 속성이 됩니다.
As an example, the following statement:
예를 들어 다음 문은
``
{{=LI(A('something', _href=URL('show', args=123))}}
``:code

is rendered as:
다음과 같이 표시됩니다.
``
<li><a href="/images/default/show/123">something</a></li>
``:code

A handful of helpers (``INPUT``, ``TEXTAREA``, ``OPTION`` and ``SELECT``) also support some special named attributes not starting with underscore (``value``, and ``requires``). They are important for building custom forms and will be discussed later.
또한 몇몇의 헬퍼들(``INPUT``, ``TEXTAREA``, ``OPTION`` and ``SELECT``)은 underscore('_')로 시작하지 않는 특별한 명명된 속성(``value``, ``requires``)을 지원합니다.  이것들은 사용자 form을 만들때 중요하며 다음에 살펴볼 것입니다.
Go back to the ''edit'' page. It now indicates that "default.py exposes index". By clicking on "index", you can visit the newly created page:
"edit""페이지로 되돌아가서 "default.py는 index를 노출하고 있다는 것을 지칭합니다.  "index"를 클릭하므로서 새로 생성된 페이지를 방문할 수 있습니다.
``
http://127.0.0.1:8000/images/default/index
``:code

which looks like:
이것은 다음과 같이 보여집니다.
[[image @///image/en2800.png center 480px]]

If you click on the image name link, you are directed to:
image의 이름 링크를 클릭하면 다음으로 전송됩니다.
``
http://127.0.0.1:8000/images/default/show/1
``:code

and this results in an error, since you have not yet created an action called "show" in controller "default.py".
이것은 에러를 발생시킵니다. 왜냐하면 아직 controller "default.py"에 "show"라는 action을 생성하지 않았기 때문입니다.
Let's edit the "default.py" controller and replace its content with:
"default.py" controller를 수정하고 다음과 같이 내용을 교체합니다.

``SQLFORM``:inxx ``accepts``:inxx ``response.flash``:inxx ``request.args``:inxx
``response.download``:inxx
``
def index():
    images = db().select(db.image.ALL, orderby=db.image.title)
    return dict(images=images)

def show():
    image = db(db.image.id==request.args(0,cast=int)).select().first()
    db.comment.image_id.default = image.id
    form = SQLFORM(db.comment)
    if form.process().accepted:
        response.flash = 'your comment is posted'
    comments = db(db.comment.image_id==image.id).select()
    return dict(image=image, comments=comments, form=form)

def download():
    return response.download(request, db)
``:code

The controller contains two actions: "show" and "download".
The "show" action selects the image with the ``id`` parsed from the request args and all comments related to the image. "show" then passes everything to the view "default/show.html".
controller는 "show"와 "download" action을 포함하고 있습니다.
"show" action은 request의 args에서 파싱한 ``id``값을 이용해서 이미지를 선택하고 또한 이미지와 연관된 코멘트를 선택합니다. 그다음 "show"는 모든 것을 "default/show.html" view에 전달합니다.
The image id referenced by:
"default/index.html"에서 아래와 같이 참조된 이미지 id는 

``
URL('show', args=image.id)
``:code

in "default/index.html", can be accessed as:
"show" action에서 다음과 같이 접근가능합니다.

``request.args(0,cast=int)``

from the "show" action. The ``cast=int`` argument is optional but very important. It attempts to cast the string value passed in the PATH_INFO into an int. On failure it raise a proper exception instead of causing a ticket. One can also specify a redirect in case of failure to cast:
``cast=int`` 인수는 생략할수 있지만 아주 중요합니다. 이것은 PATH_INFO로 전달된 스트링 값을 int값으로 변환을 시도합니다. 실패하는 경우에 티켓을 생성하지 않고 적합한 예외를 발생시킵거나 다음과 같이 리다이렉트를 지정할 수 있습니다.

``request.args(0,cast=int,otherwise=URL('error'))``

The "download" action expects a filename in ``request.args(0)``, builds a path to the location where that file is supposed to be, and sends it back to the client. If the file is too large, it streams the file without incurring any memory overhead.
"download" action에서는 ``request.args(0)``에 파일이름이 포함되어 있다고 여깁니다. 그래서 파일이 존재할 위치에 대한 패스를 만들고 이 값을 다시 클라이언트에 전송합니다. 만약에 파일이 너무 큰 경우 어떠한 메모리 추가 비용없이 스트리밍합니다. 

Notice the following statements:
- Line 7 creates an insert form SQLFORM for the ``db.comment`` table using only the specified fields.
- Line 8 sets the value for the reference field, which is not part of the input form because it is not in the list of fields specified above.
- Line 9 processes the submitted form (the submitted form variables are in ``request.vars``) within the current session (the session is used to prevent double submissions, and to enforce navigation). If the submitted form variables are validated, the new comment is inserted in the ``db.comment`` table; otherwise the form is modified to include error messages (for example, if the author's email address is invalid). This is all done in line 9!.
- Line 10 is only executed if the form is accepted, after the record is inserted into the database table. ``response.flash`` is a web2py variable that is displayed in the views and used to notify the visitor that something happened.
- Line 11 selects all comments that reference the current image.
그 다음 라인들을 살펴보면:
- 7라인은 지정된 필드들만을 이용해서 ``db.commit`` 테이블을 위한 삽입 SQLFORM form을 생성합니다.
- 8라인은 참조 필드에 대한 값을 설정합니다. 이것은 지정된 필드를에 대한 리스트에 속하지 않기 때문에 입력 form의 일부분이 아닙니다.
- 9라인은 현재 세션의 제출된 form을 처리합니다.(제출된 form의 변수들은 ``request.vars``에 포함되어 있습니다.). 현재 세션은 이중제출을 방지하고 이동을 강제하는데 사용됩니다. 제출된 form의 변수들이 유효하고 새로운 코멘트가 ``db.comment``테이블에 삽입됩니다. 그렇지 않는 경우 form은 에러 메세지를 포함하도록 변경됩니다(예를 들어 작성자의 email주소가 유효하지 않는 경우). 이러한 과정이 모두 9라인에서 처리됩니다. 
- 10라인은 레코드가 데이터베이스 테이블에 삽입되고 난 후 form이 성공적으로 처리되었을때만 샐행됩니다. ``response.flash``는 view에서 표시되는 변수로 방문자에서 어떤일이 발생했다는 것을 알리는 용도로 사용됩니다.
- 11라인은 현재 이미지를 참조하는 모든 코멘트를 선택합니다.
 
-------
The "download" action is already defined in the "default.py" controller of the scaffolding application.
"download" action은 이미 기본 생성 어플리케이션의 "default.py" controller에 정의되어 있습니다.
-------

The "download" action does not return a dictionary, so it does not need a view. The "show" action, though, should have a view, so return to **admin** and create a new view called "default/show.html".
"download" action은 dictionary를 반환하지 않기 때문에 view가 필요하지 않습니다. 하지만 "show" action은 view를 가져야 하기 때문에 **admin**에 반환하고 "default/show.html" 라는 새로운 view를 생성합니다.

Edit this new file and replace its content with the following:
이 새 파일을 수정하고 내용을 다음과 같이 수정합니다:
``
{{extend 'layout.html'}}
<h1>Image: {{=image.title}}</h1>
<center>
<img width="200px"
     src="{{=URL('download', args=image.file)}}" />
</center>
{{if len(comments):}}
  <h2>Comments</h2><br /><p>
  {{for comment in comments:}}
    <p>{{=comment.author}} says <i>{{=comment.body}}</i></p>
  {{pass}}</p>
{{else:}}
  <h2>No comments posted yet</h2>
{{pass}}
<h2>Post a comment</h2>
{{=form}}
``:code

This view displays the **image.file** by calling the "download" action inside an ``<img ... />`` tag.
If there are comments, it loops over them and displays each one.
이 view는 ``<img ... />``태그안의 "download" action을 호출해서 **image.file**을 표시합니다.
코멘트가 있는 경우에는 루프를 순회하면서 하나씩 표시합니다.

Here is how everything will appear to a visitor.
아래 그림은 어떻게 이 모든것이 방문자에게 표시되는지를 나타냅니다.

[[image @///image/en2900.png center 480px]]

When a visitor submits a comment via this page, the comment is stored in the database and appended at the bottom of the page.
이 페이지에서 방문자가 코멘트를 제출할때 코멘트는 데이터베이스에 저장되고 페이지의 마지막에 추가됩니다.

### Adding CRUD
### CRUD 추가하기

web2py also provides a CRUD (Create/Read/Update/Delete) API that simplifies forms even more. To use CRUD it is necessary to define it somewhere, such as in file "db.py":
web2py는 CRUD(Create/Read/Update/Delete) API를 제공합니다. 이것은 form을 더욱 간단하게 만들어줍니다. CRUD를 사용하기 위해서는 "db.py"같은 파일 어딘가에 선언해야 합니다: 
``
from gluon.tools import Crud
crud = Crud(db)
``:code

-------
These two lines are already in the scaffolding application.
이 두 라인은 기본 생성 어플리케이션에 포함되어 있습니다.
-------

The ``crud`` object provides high-level methods, for example:
``crud``객체는 상위수준의 메소드를 제공합니다. 예를 들어:
``
form = crud.create(table)
``:code

that can be used to replace the programming pattern:
프로그래밍 패턴을 변경하는데 사용될 수 있습니다:
``
form = SQLFORM(table)
if form.process().accepted:
    session.flash = '...'
    redirect('...')
``:code

Here, we rewrite the previous "show" action using crud and making some more improvements:
여기서는 이전에 "show" action을 crud를 이용해서 재작성하고 몇가지 개선합니다:

``
def show():
    image = db.image(request.args(0,cast=int)) or redirect(URL('index'))
    db.comment.image_id.default = image.id
    form = crud.create(db.comment,
                       message='your comment is posted',
		       next=URL(args=image.id))
    comments = db(db.comment.image_id==image.id).select()
    return dict(image=image, comments=comments, form=form)
``:code

First of all notice we have used the syntax
처음으로 살펴볼 것은 필요한 레코드를 가져오는 구문을 사용했다는 것입니다.

``
db.image(request.args(0,cast=int)) or redirect(...)
``:code

to fetch the required record. Since ```table(id)`` returns None if the record is not found, we can use ``or redirect(...)`` in this case in one line.
필요한 레코드가 존재하지 않는 경우 ``table(id)``는 None를 반환하기 때문에 이 경우 ``or redirect(...)``를 사용할 수 있습니다. 

The ``next`` argument of ``crud.create`` is the URL to redirect to after the form is accepted. The ``message`` argument is the one to be displayed upon acceptance. You can read more about CRUD in Chapter 7.
``crud.create`` 의 ``next`` 인수는 form이 처리된 이후에 리다이렉트될 URL입니다. ``message`` 인수는 처리 결과에 따라 달리 표시됩니다.
CRUD에 대해서는 7장에서 더 살펴볼 것입니다.

### Adding Authentication
### 인증추가하기

The web2py API for Role-Based Access Control is quite sophisticated, but for now we will limit ourselves to restricting access to the show action to authenticated users, deferring a more detailed discussion to Chapter 9.
역할기반 접근제어(Role-Based Access Control)을 위한 web2py API는 아주 이상적이지만 지금은 인증된 사용자들에 show action에 접근하는 것으로 제한할 것입니다. 더 자세한 논의는 9장에서 이루어 질 것입니다.
To limit access to authenticated users, we need to complete three steps. In a model, for example "db.py", we need to add:
인증된 사용자에게만 접근을 제한하기 위해서는 세가지 단계를 완료해야 합니다. 
``
from gluon.tools import Auth
auth = Auth(db)
auth.define_tables()
``:code

In our controller, we need to add one action:
contoller에 하나의 action을 추가해야 합니다:
``
def user():
    return dict(form=auth())
``:code

This is sufficient to enable login, register, logout, etc. pages. The default layout will also show options to the corresponding pages in the top right corner.
이것으로 로긴, 등록, 로그아웃등을 위한 페이지를 사용가능하기에 충분하다. 기본 레이아웃은 오른쪽 위에 해당하는 페이지에 대한 선택사항을 보여줄 것입니다. 
[[image @///image/en3000.png center 300px]]

We can now decorate the functions that we want to restrict, for example:
이제 제한하고 싶은 함수들을 decorate할수 있습니다. 예를 들어 다음과 같습니다:
``
@auth.requires_login()
def show():
    image = db.image(request.args(0,cast=int)) or redirect(URL('index'))
    db.comment.image_id.default = image.id
    form = crud.create(db.comment, next=URL(args=image.id),
                     message='your comment is posted')
    comments = db(db.comment.image_id==image.id).select()
    return dict(image=image, comments=comments, form=form)
``:code

Any attempt to access
아래와 같은 어떤 접근 시도도 로긴이 필요하게 됩니다.
``
http://127.0.0.1:8000/images/default/show/[image_id]
``:code

will require login. If the user is not logged it, the user will be redirected to
사용자가 로그인하지 않았다면 사용주는 다음 url로 리다이렉트될 것입니다.
``
http://127.0.0.1:8000/images/default/user/login
``:code

[[image @///image/en3100.png center 480px]]

The ``user`` function also exposes, among others, the following actions:
``user`` 함수 역시 다른것과 함께 다음의 action들을 노출합니다. 
``
http://127.0.0.1:8000/images/default/user/logout
http://127.0.0.1:8000/images/default/user/register
http://127.0.0.1:8000/images/default/user/profile
http://127.0.0.1:8000/images/default/user/change_password
http://127.0.0.1:8000/images/default/user/request_reset_password
http://127.0.0.1:8000/images/default/user/retrieve_username
http://127.0.0.1:8000/images/default/user/retrieve_password
http://127.0.0.1:8000/images/default/user/verify_email
http://127.0.0.1:8000/images/default/user/impersonate
http://127.0.0.1:8000/images/default/user/not_authorized
``:code

Now, a first-time user needs to register in order to be able to log in and read or post comments.
이제 처음 사용하는 사용자는 로긴을 위해서는 등록이 필요하고 코멘트를 읽고 포스트 할 수 있습니다.

-------
Both the ``auth`` object and the ``user`` function are already defined in the scaffolding application. The ``auth`` object is highly customizable and can deal with email verification, registration approvals, CAPTCHA, and alternate login methods via plugins.
``auth`` 객체와 ``user``함수는 이미 기본 생성된 어플리케이션안에 정의되어 있습니다. ``auth`` 객체는 아주 사용자 정의 가능하고 email 확인, 등록 승인, CAPTCHA, 플러그인을 통한 다른 로긴 방법을 처리할 수 있습니다.
-------

#### Adding grids
#### 그리드 추가하기

We can improve this further using the ``SQLFORM.grid`` and ``SQLFORM.smartgrid`` gadgets to create a management interface for our application:
``SQLFORM.grid``와 ``SQLFORM.smartgrid`` 가젯을 이용해서 관리 인터페이스를 생성해서 어플리케이션을 더욱 향상 시킬수 있습니다. 

``
@auth.requires_membership('manager')
def manage():
    grid = SQLFORM.smartgrid(db.image)
    return dict(grid=grid)
``:code

with associated "views/default/manage.html"
view는 "views/default/manage.html" 이용

``
{{extend 'layout.html'}}
<h2>Management Interface</h2>
{{=grid}}
``

Using appadmin create a group "manager" and make some users members of the group. They will not be able to access
appadmin을 이용해서 "manager" 그룹을 생성하고 그룹 속하는 몇명의 사용자 멤버를 생성합니다.  이제 아래 URL을 접근할 수 있고(TODO:의미상 접근할 수 있다가 맞아보임)

``
http://127.0.0.1:8000/images/default/manage
``

and browse, search:
브라우즈하고 검색할 수 있다.
[[image @///image/en3200.png center 480px]]

create, update and delete images and their comments:
이미지와 코멘트를 생성, 갱신, 삭제 할 수 있습니다.

[[image @///image/en3300.png center 480px]]

### Configuring the layout
### 레이아웃 설정하기

You can configure the default layout by editing "views/layout.html" but you can also configure it without editing the HTML. In fact, the "static/base.css" stylesheet is well documented and described in Chapter 5. You can change color, columns, size, borders and background without editing the HTML. If you want to edit the menu, the title or the subtitle, you can do so in any model file. The scaffolding app, sets default values of these parameters in the file "models/menu.py":
"views/layout.html"을 수정해서 기본 레이아웃을 설정할 수 있습니다. 하지만 HTML을 수정하지 않고도 설정할 수 있습니다. 사실 "static/base.css" 스타일시트는 문서화가 잘되어 있고 5장에 설명하고 있습니다. HTML을 수정하지 않고도 색깔,컬럼, 크기, 경계선, 배경등을 변경할 수 있습니다. 메뉴, 제목이나 부제목을 수정하려 한다면 model 파일에서 할 수 있습니다. 기본 생성 어플리케이션의 "models/menu.py" 파일에 이 파라미터에 대한 기본 값들이 설정되어 있습니다.

``
response.title = request.application
response.subtitle = T('customize me!')
response.meta.author = 'you'
response.meta.description = 'describe your app'
response.meta.keywords = 'bla bla bla'
response.menu = [ [ 'Index', False, URL('index') ] ]
``:code

### A wiki
### 위키 

``wiki``:inxx ``RSS``:inxx ``Ajax``:inxx ``XMLRPC``:inxx
In this section, we build a wiki, from scratch and without using the extended functionality provided by plugin_wiki which is described in chapter 12. The visitor will be able to create pages, search them (by title), and edit them. The visitor will also be able to post comments (exactly as in the previous applications), and also post documents (as attachments to the pages) and link them from the pages. As a convention, we adopt the Markmin syntax for our wiki syntax. We will also implement a search page with Ajax, an RSS feed for the pages, and a handler to search the pages via XML-RPC``xmlrpc``:cite .
이번에는 12장에 설명하고 있는 plugin_wiki의 기능을 사용하지 않고 위키를 처음부터 만듭니다. 방문자는 페이지를 만들고 제목으로 검색하고 편집할 수 있게됩니다. 또한 코멘트를 (이전 어플리케이션과 동일하게)포스트 할 수도 있습니다. 그리고 페이지에 첨부하는 문서를 포스트 할 수도 있고 링크할 수도 있습니다.이전처럼 위키 구문으로 Markmin을 채용합니다. 또한 AJax를 통한 검색페이지를 구현하고  RSS 피드, XML-RPC``xmlrpc``:cite를 통해서 페이지를 검색할 수 있는 핸들러를 구현할 것입니다. 

The following diagram lists the actions that we need to implement and the links we intend to build among them.
다음 다이어그램은 구현해야할 action목록과 구축해야할 링크의 목록을 나타냅니다. 

[[yUML diagram @///image/en3400.png center 250px]]

Start by creating a new scaffolding app, naming it "mywiki".
"mywiki"라는 이름의 새로운 기본 어플리케이션을 생성하는 것으로 시작하겠습니다.

The model must contain three tables: page, comment, and document. Both comment and document reference page because they belong to page. A document contains a file field of type upload as in the previous images application.
model은 page, comment, document 3개의 테이블을 가지고 있어야 합니다. comment 와 docuement 테이블은 page에 속하기 때문에 page 테이블을 참조합니다. document 테이블은 이전 images 어플리케이션에서처럼 upload 타입의 file 필드를 포함하고 있습니다.

Here is the complete model:
다음은 완전한 model내용입니다.

``
db = DAL('sqlite://storage.sqlite')

from gluon.tools import *
auth = Auth(db)
auth.define_tables()
crud = Crud(db)

db.define_table('page',
    Field('title'),
    Field('body', 'text'),
    Field('created_on', 'datetime', default=request.now),
    Field('created_by', 'reference auth_user', default=auth.user_id),
    format='%(title)s')

db.define_table('comment',
    Field('page_id', 'reference page'),
    Field('body', 'text'),
    Field('created_on', 'datetime', default=request.now),
    Field('created_by', 'reference auth_user', default=auth.user_id))

db.define_table('document',
    Field('page_id', 'reference page'),
    Field('name'),
    Field('file', 'upload'),
    Field('created_on', 'datetime', default=request.now),
    Field('created_by', 'reference auth_user', default=auth.user_id),
    format='%(name)s')

db.page.title.requires = IS_NOT_IN_DB(db, 'page.title')
db.page.body.requires = IS_NOT_EMPTY()
db.page.created_by.readable = db.page.created_by.writable = False
db.page.created_on.readable = db.page.created_on.writable = False

db.comment.body.requires = IS_NOT_EMPTY()
db.comment.page_id.readable = db.comment.page_id.writable = False
db.comment.created_by.readable = db.comment.created_by.writable = False
db.comment.created_on.readable = db.comment.created_on.writable = False

db.document.name.requires = IS_NOT_IN_DB(db, 'document.name')
db.document.page_id.readable = db.document.page_id.writable = False
db.document.created_by.readable = db.document.created_by.writable = False
db.document.created_on.readable = db.document.created_on.writable = False
``:code

Edit the controller "default.py" and create the following actions:
- index: list all wiki pages
- create: post another wiki page
- show: show a wiki page and its comments, and append comments
- edit: edit an existing page
- documents: manage the documents attached to a page
- download: download a document (as in the images example)
- search: display a search box and, via an Ajax callback, return all matching titles as the visitor types
- callback: the Ajax callback function. It returns the HTML that gets embedded in the search page while the visitor types.
"default.py" controller를 수정하고 다음 action들을 생성합니다.
- index: 모든 wiki 페이지에 대한 목록을 표시합니다.
- create: 새로운 wiki page를 포스트 합니다.
- show: wiki 페이지와 페이지의 코멘트를 보여주고 코멘트를 추가합니다.
- edit: 페이지를 수정합니다.
- documents: 페이지에 첨부되어 있는 문서를 관리합니다.
- download: images 예제에서처럼 문서를 다운로드 합니다.
- search: 검색 박스를 표시하고 Ajax콜백을 통해서 방문자의 입력과 일치하는 모든 타이틀을 반환합니다.
- callback: Ajax 콜백함수입니다. 반환된 HTML은 사용자가 입력하는 동안 검색페이지에 포함됩니다.

Here is the "default.py" controller:
다음은 "default.py" controller입니다.
``
def index():
     """ this controller returns a dictionary rendered by the view
         it lists all wiki pages
     >>> index().has_key('pages')
     True
     """
     pages = db().select(db.page.id,db.page.title,orderby=db.page.title)
     return dict(pages=pages)

@auth.requires_login()
def create():
     "creates a new empty wiki page"
     form = crud.create(db.page, next=URL('index'))
     return dict(form=form)

def show():
     "shows a wiki page"
     this_page = db.page(request.args(0,cast=int)) or redirect(URL('index'))
     db.comment.page_id.default = this_page.id
     form = crud.create(db.comment) if auth.user else None
     pagecomments = db(db.comment.page_id==this_page.id).select()
     return dict(page=this_page, comments=pagecomments, form=form)

@auth.requires_login()
def edit():
     "edit an existing wiki page"
     this_page = db.page(request.args(0,cast=int)) or redirect(URL('index'))
     form = crud.update(db.page, this_page,
                        next=URL('show',args=request.args))
     return dict(form=form)

@auth.requires_login()
def documents():
     "browser, edit all documents attached to a certain page"
     page = db.page(request.args(0,cast=int)) or redirect(URL('index'))
     db.document.page_id.default = page.id
     db.document.page_id.writable = False
     grid = SQLFORM.grid(db.document.page_id==page.id,args=[page.id])
     return dict(page=page, grid=grid)

def user():
     return dict(form=auth())

def download():
     "allows downloading of documents"
     return response.download(request, db)

def search():
     "an ajax wiki search page"
     return dict(form=FORM(INPUT(_id='keyword',_name='keyword',
              _onkeyup="ajax('callback', ['keyword'], 'target');")),
              target_div=DIV(_id='target'))

def callback():
     "an ajax callback that returns a <ul> of links to wiki pages"
     query = db.page.title.contains(request.vars.keyword)
     pages = db(query).select(orderby=db.page.title)
     links = [A(p.title, _href=URL('show',args=p.id)) for p in pages]
     return UL(*links)
``:code


Lines 2-6 provide a comment for the index action. Lines 4-5 inside the comment are interpreted by python as test code (doctest). Tests can be run via the admin interface. In this case the tests verify that the index action runs without errors.
2-6라인은 index action을 위한 코멘트를 제공합니다. 코멘트내의 4-5라인(doctest)은 python에 의해서 테스트 코드로 번역됩니다. 테스트들은 admin인터페이스에서 실행 가능합니다. 이경우 테스트는 index action이 에러없이 동작하는것을 검증합니다.  

Lines 18, 27, and 35 try to fetch a ``page`` record with the id in
18,27, 35라인은 ``request.args(0)``에 id에 해당하는 ``page``레코드를 가져오려 시도합니다. 
``request.args(0)``.

Lines 13, 20 define and process create forms for a new page and a new comment and.
13,20라인은 새로운 페이지와 새로운 코멘트를 위한 생성form을 정의하고 처리합니다.

Line 28 defines and processes an update form for a wiki page.
28라인은 wiki페이지를 위한 갱신form을 정의하고 처리합니다.

Line 38 creates a ``grid`` object that allows to browser, add and update the comments linked to a page.
38라인은 ``grid``객체를 생성하고 페이지에 연결된 코멘트를 브라우지, 추가, 갱신할수 있도록 해줍니다.

Some magic happens in line 51. The ``onkeyup`` attribute of the INPUT tag "keyword" is set. Every time the visitor releases a key, the JavaScript code inside the ``onkeyup`` attribute is executed, client-side. Here is the JavaScript code:
51라인에서 마술이 일어 납니다. INPUT 태그 "keyword"의 ``onkeyup`` 속성이 설정됩니다. 방문자가 키를 해제할 때마다 ``onkeyup`` 속성내의 Javascript코드가 클라이언트 측에서 실행됩니다.
다음은 Javascript코드입니다.  
``
ajax('callback', ['keyword'], 'target');
``:code
``ajax`` is a JavaScript function defined in the file "web2py.js" which is included by the default "layout.html". It takes three parameters: the URL of the action that performs the synchronous callback, a list of the IDs of variables to be sent to the callback (["keyword"]), and the ID where the response has to be inserted ("target").
``ajax``는 JavaScript함수이면 "web2py.js"에 정의되어 있습니다. 이것은 기본 "layout.html"에 의해서 포함됩니다. 세개의 파라미터를 가집니다: 순차적으로 콜백을 수행할 action에 대한 URL, callback으로 보내질 변수들의 ID에 대한 리스트(["keywork"]), 응답이 삽입될 ID("target")   

As soon as you type something in the search box and release a key, the client calls the server and sends the content of the 'keyword' field, and, when the sever responds, the response is embedded in the page itself as the innerHTML of the 'target' tag.
검색박스에 입력하고 키를 놓는 순간, 클라이언트는 서버를 호출하고 'keyword'필드의 내용을 전송합니다. 서버가 응답하면 그 내용은 페이지내의 'taget'태그의 innerHTML로 다시 포함됩니다. 
The 'target' tag is a DIV defined in line 52. It could have been defined in the view as well.
'target' 태크는 DIV이면 52라인에 정의되어 있습니다. view에 정의될 수도 있습니다.  

Here is the code for the view "default/create.html":
"default/create.html" view를 위한 코드입니다:
``
{{extend 'layout.html'}}
<h1>Create new wiki page</h1>
{{=form}}
``:code

If you visit the **create** page, you see the following:
**create**페이지를 방문하면 다음과 같이 볼 수 있습니다.
[[image @///image/en3500.png center 480px]]

Here is the code for the view "default/index.html":
아래는 "default/index.html" view를 위한 코드입니다:
``
{{extend 'layout.html'}}
<h1>Available wiki pages</h1>
[ {{=A('search', _href=URL('search'))}} ]<br />
<ul>{{for page in pages:}}
     {{=LI(A(page.title, _href=URL('show', args=page.id)))}}
{{pass}}</ul>
[ {{=A('create page', _href=URL('create'))}} ]
``:code

It generates the following page:
이것은 다음 페이지를 생성합니다:

[[image @///image/en3600.png center 480px]]

Here is the code for the view "default/show.html":
"default/show.html" view를 위한 코드입니다:

``markdown``:inxx ``MARKMIN``:inxx
``
{{extend 'layout.html'}}
<h1>{{=page.title}}</h1>
[ {{=A('edit', _href=URL('edit', args=request.args))}}
| {{=A('documents', _href=URL('documents', args=request.args))}} ]<br />
{{=MARKMIN(page.body)}}
<h2>Comments</h2>
{{for comment in comments:}}
  <p>{{=db.auth_user[comment.created_by].first_name}} on {{=comment.created_on}}
          says <I>{{=comment.body}}</i></p>
{{pass}}
<h2>Post a comment</h2>
{{=form}}
``:code

If you wish to use markdown syntax instead of markmin syntax:
markmin 구문을 사용하는 대신에 markdown을 사용하길 원한다면 ``MARKMIN``대신 ``WIKI``헬퍼를 사용합니다.

``
from gluon.contrib.markdown import WIKI
``:code

and use ``WIKI`` instead of the ``MARKMIN`` helper.
Alternatively, you can choose to accept raw HTML instead of markmin syntax. In this case you would replace:
대안으로 markmin 구문대신에 HTML자체를 받아들이도록 할 수 있습니다. 이 경우 다음과 같이 변경합니다:
``
{{=MARKMIN(page.body)}}
``:code

with:
다음과 같이 변경:
``
{{=XML(page.body)}}
``:code

``sanitize``:inxx
(so that the XML does not get escaped, as by default web2py behavior).
(이렇게해서 XML이 escape되지 않도록 합니다.기본적으로 web2py는 escape합니다.)
This can be done better with:
이것은 다음과 같이하면 더 좋습니다:
``
{{=XML(page.body, sanitize=True)}}
``:code

By setting ``sanitize=True``, you tell web2py to escape unsafe XML tags such as "<script>", and thus prevent XSS vulnerabilities.
``sanitize=True``로 설정함으로써  web2py에게 "<script>"와 같은 안전하지 않은 XML을 escape하도록 알려주고 XML 취약성을 막습니다.


Now if, from the index page, you click on a page title, you can see the page that you have created:
이제 index 페이지에서 페이지 제목을 클릭하면 생성한 페이지를 볼 수 있습니다:

[[image @///image/en3700.png center 480px]]

Here is the code for the view "default/edit.html":
이것은 "default/edit.html"view를 위한 코드입니다:
``
{{extend 'layout.html'}}
<h1>Edit wiki page</h1>
[ {{=A('show', _href=URL('show', args=request.args))}} ]<br />
{{=form}}
``:code

It generates a page that looks almost identical to the create page.
이 코드는 생성 페이지와 거의 동일하게 보이는 페이지를 생성합니다.

Here is the code for the view "default/documents.html":
다음은 "defalt/documents.html" view 코드입니다:
``
{{extend 'layout.html'}}
<h1>Documents for page: {{=page.title}}</h1>
[ {{=A('show', _href=URL('show', args=request.args))}} ]<br />
<h2>Documents</h2>
{{=grid}}
``:code

If, from the "show" page, you click on documents, you can now manage the documents attached to the page.
"show"페이지에서 documents를 클릭하면 이제 페이지에 첨부된 문서들을 관리할 수 있습니다.

[[image @///image/en3800.png center 480px]]

Finally here is the code for the view "default/search.html":
마지막으로 "default/search.html" view를 위한 코드입니다:
``
{{extend 'layout.html'}}
<h1>Search wiki pages</h1>
[ {{=A('listall', _href=URL('index'))}}]<br />
{{=form}}<br />{{=target_div}}
``:code

which generates the following Ajax search form:
다음과 같은 Ajax검색 form을 생성합니다: 

[[image @///image/en3900.png center 480px]]

You can also try to call the callback action directly by visiting, for example, the following URL:
다음 URL을 방문해서 직접적으로 callback action을 호출을 시도할 수 있습니다:
``
http://127.0.0.1:8000/mywiki/default/callback?keyword=wiki
``:code

If you look at the page source you see the HTML returned by the callback:
페이지 소스를 보면 callback에서 반환한 HTML을 볼 수 있습니다:
``
<ul><li><a href="/mywiki/default/show/4">I made a Wiki</a></li></ul>
``:code

``rss``:inxx
Generating an RSS feed from the stored pages using web2py is easy because web2py includes ``gluon.contrib.rss2``. Just append the following action to the default controller:
web2py를 이용해서 저당된 페이지에서 RSS 피드를 생성하는 것은 ``gluon.contrib.rss2``를 포함되어 있기때문에 쉽습니다. 기본 controller에 다음과 같은 action을 추가하면 끝입니다:
``
def news():
    "generates rss feed form the wiki pages"
    reponse.generic_patterns = ['.rss']
    pages = db().select(db.page.ALL, orderby=db.page.title)
    return dict(
       title = 'mywiki rss feed',
       link = 'http://127.0.0.1:8000/mywiki/default/index',
       description = 'mywiki news',
       created_on = request.now,
       items = [
          dict(title = row.title,
               link = URL('show', args=row.id),
               description = MARKMIN(row.body).xml(),
               created_on = row.created_on
               ) for row in pages])
``:code

and when you visit the page
다음 페이지를 방문하면 피드를 볼 수 있습니다.(정확한 출력은 피드 리더에 따라 다릅니다.)
``
http://127.0.0.1:8000/mywiki/default/news.rss
``:code

you see the feed (the exact output depends on the feed reader). Notice that the dict is automatically converted to RSS, thanks to the .rss extension in the URL.
dict는 자동으로 RSS로 변환된다는 것에 주목하세요. 다 URL의 .rss 확장자 덕분이죠.

[[image @///image/en4000.png center 480px]]

web2py also includes feedparser to read third-party feeds.
web2py는 또한 제3의 피드도 읽어 들일 수 있는 피드파서가 포함되어 있습니다.

``XMLRPC``:inxx
Finally, let's add an XML-RPC handler that allows searching the wiki programmatically:
마지감으로 wiki를 프로그래밍적으로 검색할 수 있는 XML-PRC 핸들러를 추가해 보도록 합니다:
``
service = Service()

@service.xmlrpc
def find_by(keyword):
     "finds pages that contain keyword for XML-RPC"
     return db(db.page.title.contains(keyword)).select().as_list()

def call():
    "exposes all registered services, including XML-RPC"
    return service()
``:code

Here, the handler action simply publishes (via XML-RPC), the functions specified in the list. In this case, ``find_by``. ``find_by`` is not an action (because it takes an argument). It queries the database with ``.select()`` and then extracts the records as a list with ``.response`` and returns the list.
여기서는 handler action은 리스트에 지정된 함수들을 단순히 배포(XML-RPC를 통해서)하는 일만합니다. 이 경우 ``find_by``이며 ``find_by``는 인수를 취하기 때문에 action이 아닙니다. 이 것은 ``select()``로 데이터베이스를 쿼리한후 레코드를 ``.response``를 갖는 리스트를 추출하고 반환합니다. 

Here is an example of how to access the XML-RPC handler from an external
Python program.
이번 예제는 어떻게 외부 Python 프로그램에서 XML-RPC 핸들러를 접근하는지 보여줍니다.
``
>>> import xmlrpclib
>>> server = xmlrpclib.ServerProxy(
    'http://127.0.0.1:8000/mywiki/default/call/xmlrpc')
>>> for item in server.find_by('wiki'):
        print item['created_on'], item['title']
``:code

The handler can be accessed from many other programming languages that understand XML-RPC, including C, C++, C# and Java.
핸들러는 XML-RPC를 지원하는 어떤 프로그래밍 언어, 예를 들어 C, C++, C#, Java등 에서도 접근 가능합니다.

#### On ``date``, ``datetime`` and ``time`` format
#### ``data``, ``datetime``, ``time`` 형식에 대해서

There are three different representation for each of the field types ``date``, ``datetime`` and ``time``:
- the database representation
- the internal web2py prepresentation
- the string representation in forms and tables
``data``, ``datetime``, ``time``의 각각의 필드는 다른 3가지의 표현이 있습니다:
- 데이터베이스 표현방법
- web2py 내부 표현방법
- form이나 table내에서 문자열 표현


The database representation is an internal issue and does not affect the code. Internally, at the web2py level, they are stored as ``datetime.date``, ``datetime.datetime`` and ``datetime.time`` object respectively and they can be manipulated as such:
데이터베이스 표현방법은 내부 이슈이고 코드에는 영향을 미치지 않습니다. 내부적으로 web2py 레벨에서 ``datetime.data``, ``datetime.datetime``, ``datetime.time`` 객체로 저장되고 다음과 같이 처리될 수 있습니다:

``
for page in db(db.page).select():
    print page.title, page.day, page.month, page.year
``

When dates are converted to strings in forms they are converted using the ISO representation
form내에서 date가 문자열로 변화될때는 ISO 표현방법을 사용합니다. 
``
%Y-%m-%d %H:%M:%S
``

yet this representation in internationalized and you can use the admin stranslation page to change the format to an alternate one. For example:
이미 이 표현방법은 국제화되어 있으면 admin 변환 페이지에서 다른 것으로 형식을 변환할때 사용할 수 있습니다. 예를 들면 다음과 같습니다:

``
%m/%b/%Y %H:%M:%S
``

------
Mind that by default English is not translated because web2py assumes the applications is already written in English. If you want internationalization to work for English you need to create the translation file (using admin) and you need declare that the application current language is something other than english, for example:
web2py는 어플리케이션이 이미 영어로 작성되었다고 가정하기 때문에 영어는 변역하지 않는다는 것을 염두해 두어야 합니다. 영어에 대한 국제화 작업을 원한다면 admin을 이용해서 번역파일을 생성해야 하고 현재 언어가 영어가 아닌 다른 언어인 어플리케이션을 정의해야 합니다. 예를 들면:  
``
T.current_languages = ['null']
``
------




### More on **admin**
### **admin**에 대한 더 알아보기
``admin``:inxx

The administrative interface provides additional functionality that we briefly review here.
관지자 인터페이스는 여기에서 살펴볼 추가적인 기능을 제공합니다.

#### ''site''
#### ''site''
``site``:inxx

This page lists all installed applications. There are two forms at the bottom.
이페이지는 설치된 모든 어플리케이션 목록을 표시합니다. 아래쪽에 2개의 form이 있습니다.

The first of them allows creating a new application by specifying its name.
첫번째 form은 이름을 지정해서 새로운 어플리케이션을 생성해줍니다.

``Instant Press``:inxx
The second form allows uploading an existing application from either a local file or a remote URL. When you upload an application, you need to specify a name for it. This can be its original name, but does not need to be. This allows installing multiple copies of the same application. You can try, for example, to upload the the Instant Press CMS created by Martin Mulone from:
두번째 form은 로컬 파일이나 리모트URL을 통해 이미 존재하는 어플리케이션을 업로드할 수 있도록 해줍니다. 어플리케이션을 업로드할때 이름을 지정해야 합니다. 이름은 원래것일 수도 있지만 꼭 그럴 필요는 없습니다. 이 것을 이용해서 같은 어플리케이션을 여러개 설치할 수 있습니다. 예를 들어 Martin Mulone이 만든 Instant Press CMS을 업로드 할 수 있습니다:

``
http://code.google.com/p/instant-press/
``:code

------
Web2py files are packages as ``.w2p`` files. These ones are tar gzipped files. Web2py uses the ``.w2p`` extension instead of the ``.tgz`` extension to prevent the browser from unzipping on download. They can be uncompressed manually with ``tar zxvf [filename]`` although this is never necessary.
web2py파일은 ``.w2p``파일로 패키징되고 tar gzip된 파일입니다. web2py는 다운로드시 브라우져에서 unzipp하는 것을 막기 위해서 ``.w2p``확장자를 사용합니다. 필요하지는 않지만 ``tar zxvf [filename]``를 통해서 수동으로 해제할 수 있습니다. 
------

[[image @///image/en4100.png center 444px]]

Upon successful upload, web2py displays the MD5 checksum of the uploaded file. You can use it to verify that the file was not corrupted during upload. The InstantPress name will appear in the list of installed applications.
성공적으로 업로드 되면 web2py는 업로드된 파일에 대한 MD5 체크섬을 출력합니다. 이 값을 이용해서 업로드하는 동안 파일에 이상이 없는지를 검증하는데 사용할 수 있습니다. InstantPress이름이 설치된 어플리케이션 모록에 표시될 것입니다.

Click on the InstantPress name on admin to get it up and running.
구동시키기위해서 admin에서 InstantPress이름을 클릭합니다. 

[[image @///image/en4200.png center 480px]]

You can read more about Instant Press at the following URL:
InstantPress에 대해서 자세한 내용은 다음 URL에서 확인 할 수 있습니다:
``
http://code.google.com/p/instant-press/
``

For each application the ''site'' page allows you to:
- Uninstall the application.
- Jump to the ''about'' page (read below).
- Jump to the ''edit'' page (read below).
- Jump to the ''errors'' page (read below).
- Clean up temporary files (sessions, errors, and cache.disk files).
- Pack all. This returns a tar file containing a complete copy of the application. We suggest that you clean up temporary files before packing an application.
- Compile the application. If there are no errors, this option will bytecode-compile all models, controllers and views. Because views can extend and include other views in a tree, before bytecode compilation, the view tree for every controller is collapsed into a single file. The net effect is that a bytecode-compiled application is faster, because there is no more parsing of templates or string substitutions occurring at runtime.
- Pack compiled. This option is only present for bytecode-compiled applications. It allows packing the application without source code for distribution as closed source. Note that Python (as any other programming language) can technically be decompiled; therefore compilation does not provide complete protection of the source code. Nevertheless, decompilation can be difficult and can be illegal.
- Remove compiled. It simply removes the byte-code compiled models, views and controllers from the application. If the application was packaged with source code or edited locally, there is no harm in removing the bytecode-compiled files, and the application will continue to work. If the application was installed form a packed compiled file, then this is not safe, because there is no source code to revert to, and the application will no longer work.
각 어플리케이션의 ``site`` 페이지에서는 다음과 같은 것을 할 수 있습니다:
- 어플리케이션 제거
- ''about''페이지로 이동(아래 내용 참조)
- ''edit''페이지로 이동(아래 내용 참조)
- ''errors''페이지로 이동(아래 내용 참조)
- 임시 파일들(session, error, cache.disk 파일들)
- 어플리케이션을 tar파일 하나로 묶어서 반환합니다. 하나로 묶기전에 먼저 임시 파일들을 삭제하기를 권장합니다.
- 어플리케이션 컴파일. 에러가 없다면 모든 model, controller, view들을 bytecode컴파일 할 것입니다. view는 tree형태로 다른 view를 확장하고 포함할 수 있기 때문에 bytecode 컴파일 전에 모든 controller에 대한 view tree를 하나의 파일로 만들어야 합니다. bytecode 컴파일의 효과는 더 빠르다는 것입니다. 왜냐하면 런타임에 template을 파싱하거나 문자열을 교체하는 일이 없기 때문입니다.
- 컴파일된 어플리케이션 묶기. 이 옵션은 bytecode 컴파일된 어플리케이션에만 존재합니다. 어플리케이션을 소스 없이 배포할 수 있도록 해줍니다. 다른 프로그래밍 언어들처럼 Python은 기술적으로 디컴파일 가능합니다. 그래서 컴파일로 소스코드를 보호해주지는 못합니다. 그럼에도 불구하고 디컴파일은 어렵고 불법일 수 있습니다.
- 컴파일된 코드 제거. bytecode컴파일된 model, view, controller를 제거합니다. 어플리케이션이 소스코드와 함께 묶여 있거나 로컬에서 수정된 경우 bytecode 컴파일된 코드를 제거하는 것은 아무런 문제가 없으며 어플리케이션은 문제없이 동작할 것입니다. 어플리케이션이 컴파일된 파일 묶음을 통해 설치된 경우에는 안전하지 않습니다. 왜냐하면 원복할 소스가 없기때문에 어플리케이션은 더이상 동작하지 않을 것입니다.    

``admin.py``:inxx

-------
All the functionality available from the web2py admin site page is also accessible programmatically via the API defined in the module ``gluon/admin.py``. Simply open a python shell and import this module.
web2py admin site 페이지에서 가능함 모든 기능들은 ``gluon/admin.py`` 모듈에 정의된 API를 통해서 프로그래밍적으로 접근 가능합니다. python shell 을 하나 열고 다음 모듈을 import합니다.
-------

#### ''about''
``about``:inxx ``license``:inxx

The ''about'' tab allows editing the description of the application and its license. These are written respectively in the ABOUT and LICENSE files in the application folder.
''about'' 탭에서는 어플리케이션의 설명과 라이센스를 수정할 수 있습니다. 각각은 어플리케이션 폴더내에 ABOUT, LICENSE파일에 각각 작성되어 있습니다.

[[image @///image/en4300.png center 480px]]

You can use ``MARKMIN``, or ``gluon.contrib.markdown.WIKI`` syntax for these files as described in ref.``markdown2``:cite .
이 파일들에  ``MARKMIN`` 구문이나 ``markdown2``:cite에 설명된 ``glueon.contrib.markdown.WIFI`` 구문을 사용할 수 있습니다.

#### ''edit''
``EDIT``:inxx
You have used the ''edit'' page already in this chapter. Here we want to point out a few more functionalities of the ''edit'' page.
- If you click on any file name, you can see the contents of the file with syntax highlighting.
- If you click on edit, you can edit the file via a web interface.
- If you click on delete, you can delete the file (permanently).
- If you click on test, web2py will run tests. Tests are written by the developer using Python doctests, and each function should have its own tests.
- You can add language files, scan the app to discover all strings, and edit string translations via the web interface.
- If the static files are organized in folders and subfolders, the folder hierarchy can be toggled by clicking on a folder name.
이번 장에서 이미 ''edit''페이지를 사용했습니다. 이번에는 ''edit''페이지의 추가적인 기능에 대해서 짚어 볼 것입니다.
- 어떤 파일 이름을 클릭하든지 파일 내용이 syntax highlighting되어 표시됩니다.
- edit를 클릭하면 web interface를 통해서 파일을 수정할 수 있습니다.
- delete를 클릭하면 파일을 영원히 지울 수 있습니다.
- test를 클릭하면 web2py는 test를 실행합니다. test는 Python doctest를 이용해서 개발자가 작성한 것입니다. 각 함수는 각자의 test를 가지고 있어야 합니다.
- web 인터페이스르 통해서 언어 파일을 추가할 수 있고 어플리케이션의 모든 문자들을 스캔하고 문자 번역들을 수정할 수 있습니다.
- 정적 파일들이 폴더나 서브폴더로 구성되어 있는 경우 폴더명을 클릭하면 폴더 구조를 변경할 수 있습니다. 

The image below shows the output of the test page for the welcome application.
다음 이미지는 welcome 어플리케이션의 test 페이지의 출력을 보여줍니다.

[[image @///image/en4400.png center 480px]]

The image below show the languages tab for the welcome application.
아래 이미지는 welcome어플리케이션의 언어탭을 보여줍니다.

[[image @///image/en4500.png center 480px]]

The image below shows how to edit a language file, in this case the "it" (Italian) language for the welcome application.
아래 이미지는 언어 파일을 수정하는 방법을 보여주빈다. 이 경우 welcome어플리케이션의 "it"(이탈이아) 언어입니다.

[[image @///image/en4600.png center 480px]]

##### ''shell''

If you click on the "shell" link under the controllers tab in ''edit'', web2py will open a web based Python shell and will execute the models for the current application. This allows you to interactively talk to your application.
''edit'' 페이지의 controller 탭 아래 "shell"링크를 클릭하면 web2py는 web기반의 Python shell을 생성하고 현재 어플리케이션의 model들을 실행할 것입니다. 이 것을 이용해서 어플리케이션과 대화할 수 있습니다.

[[image @///image/en4700.png center 480px]]

##### ''crontab''

Also under the controllers tab in ''edit'' there is a "crontab" link. By clicking on this link you will be able to edit the web2py crontab file. This follows the same syntax as the unix crontab but does not rely on unix. In fact, it only requires web2py, and it works on Windows. It allows you to register actions that need to be executed in background at scheduled times.
For more information about this, see the next chapter.
''edit''페이지의 controller 탭에는 "crontab"링크도 있습니다. 이 링크를 클릭하면 web2py crontab파일을 수정할 수 있습니다. 이 파일은 unix 의 crontab 구문을 따르지만 unix와는 독립적입니다. 사실 web2py만이 필요하고 Windows에서도 동작합니다. 정해진 시간에 배경에서 실행될 action을 등록할 수 있습니다.
더 많은 정보는 다음 장에서 살펴볼 것입니다.

#### ''errors''
``errors``:inxx
When programming web2py, you will inevitably make mistakes and introduce bugs. web2py helps in two ways: 1) it allows you to create tests for every function that can be run in the browser from the ''edit'' page; and 2) when an error manifests itself, a ticket is issued to the visitor and the error is logged.
web2py를 프로그래밍 할때 실수로 할 것이고 버그도 만들 것입니다. 이런경우 web2py는 2가지 방법으로 도움을 줍니다. 1) ''edit''페이지에서 브라우저내에서 실행가능한 각 함수를 위한 test을 생성할 수 있도록 해주며, 2) 에러가 발생하면 ticket이 생성되고 방문자에게 표시되고, 에러는 로깅됩니다. 

Intentionally introduce an error in the images application as shown below:
의도적으로 images어플리케이션에 에러를 만듭니다:
``
def index():
    images = db().select(db.image.ALL,orderby=db.image.title)
    1/0
    return dict(images=images)
``:code

When you access the index action, you get the following ticket:
index action을 접근하면 다음의 ticket을 보게 될 것입니다:

[[image @///image/en4800.png center 480px]]

Only the administrator can access the ticket:
오직 관리자만 ticket에 접근가능합니다:


[[image @///image/en4900.png center 480px]]

The ticket shows the traceback, and the content of the file that caused the problem, and the complete state of system (variables, request, session, etc.) If the error occurs in a view, web2py shows the view converted from HTML into Python code. This allows to easily identify the logical structure of the file.
티켓에는 트레이스백, 문제를 발생한 파일의 내용, 완전한 시스템 상태(변수,요청,세션등)을 보여줍니다. 에러가 view에서 발생한 경우 web2py는 view를 HTML에서 Python 코드로 변환해서 보여줍니다. 이렇게 해서 파일의 논리적인 구조를 쉽게 인식할 수 있도록 해줍니다.

By default tickets are stored on filesystem and group by traceback. The administrative interface provides an aggregate views (type of traceback and number of occurrence) and a detailed view (all tickets are listed by ticket id). The administrator can switch between the two views.

Notice that everywhere **admin** shows syntax-highlighted code (for example, in error reports, web2py keywords are shown in orange). If you click on a web2py keyword, you are redirected to a documentation page about the keyword.
**admin**어디에서든 syntax-highligh된 코드를 보여줍니다.(예를 들어 error 레포트에서 web2py keyword는 오렌지색으로 보여집니다). web2py keyword를 클릭하면 해당 keyword를 설명한 문서로 리다이렉트됩니다.

If you fix the divide-by-zero bug in the index action and introduce one in the index view:
index action에서 divide-by-zero버그를 수정하고 view에 다시 에러를 발생시킨다면 다음과 같은 ticket을 얻게 됩니다:
``
{{extend 'layout.html'}}

<h1>Current Images</h1>
<ul>
{{for image in images:}}
{{1/0}}
{{=LI(A(image.title, _href=URL("show", args=image.id)))}}
{{pass}}
</ul>
``:code

you get the following ticket:

[[image @///image/en5000.png center 480px]]

Note that web2py has converted the view from HTML into a Python file, and the error described in the ticket refers to the generated Python code and NOT to the original view file:
web2py는 view를 HTML에서 Python 코드로 변환하고 ticket에 설명된 에러는 생성된 Python코드를 참조하고 있습니다. 원본 view파일이 아님을 주목하세요:

[[image @///image/en5100.png center 480px]]

This may seem confusing at first, but in practice it makes debugging easier, because the Python indentation highlights the logical structure of the code that you embedded in the views.
이런 동작은 처음에는 혼란스러울수 있지만 실제 디버깅을 쉽게해줍니다. 왜냐하면 view에 포함시킨 Python 들여쓰기는 코드의 논리적인 구조를 드러냅니다.

The code is shown at the bottom of the same page.
코드는 같은 페이지 아래쪽에 표시됩니다.

All tickets are listed under admin in the ''errors'' page for each application:
모든 ticket은 어플리케이션의 admin의 ''errors''페이지에 목록으로 표시됩니다.

[[image @///image/en5200.png center 480px]]

#### ''Mercurial''
``Mercurial``:inxx

If you are running from source and you have the Mercurial version control libraries installed:
소스에서 구동하고 Mercurial 버전 컨트롤 라이브러리를 설치해 두었다면:
``
easy_install mercurial
``:code

then the administrative interface shows one more menu item called "Versioning". It automatically creates a local Mercurial repository for the application. Pressing the "commit" button in the page will commit the current application. Mercurial creates and stores information about changes you make in your code into a hidden folder ".hg" in your app subfolder. Every app has its own ".hg" folder and its own ".hgignore" file (tells Mercurial which files to ignore).
관리자 인터페이스는 "Versioning"이라는 아이템하나를 더 보여줍니다. 이것은 자동으로 어플리케이션에 대한 로컬 Mercurial 저장소를 생성합니다. 페이지의 "commit"을 선택하면 현재 어플리케이션을 commit합니다. Mercurial은 코드를 수정한 정보를 어플리케이션 하위폴더에 ".hg"라는 숨김폴더안에 저장합니다. 각 어플리케이션은 각자의 ".hg" 폴더를 가지고 또한  Mercurial에게 어떤 파일을 무시해야 할지를 가르키는 ".hgignore"파일을 가집니다. 

The Mercurial web interface does allow you to browse previous commit and diff files but we do recommend you use Mercurial directly from the shell or one of the many GUI-based Mercurial clients since they are more powerful. For example they will allow you sync your app with a remote source repository:
Mercurial 웹 인터페이스는 이전 커밋, 파일 변경사항등을 볼수 있도록 해주지만 shell에서 직접적 Mercurial을 사용하기를 권장합니다. 또는 GUI를 기반으로하고 기능도 많은 다른 Mercurial 클라이언트 사용을 권장합니다. 이런 클라이언트들은 원격의 소스 저장소와 어플리케이션을 동기화시켜 줍니다.

[[images @///image/en5300.png center 480px]]


You can read more about Mercurial here:
Mercurial에 대한 더 많은 내용은 아래에서 확인할 수 있습니다:
``
http://mercurial.selenic.com/
``

#### Admin wizard (experimental) Admin 마법사(실험)

The **admin** interface includes a Wizard that can help you create a new applications.
You can access the wizard from the "sites" page as shown in the image below.
**admin** 인터페이스는 새로운 어플리케이션 생성을 도와주는 마법사가 포함되어 있습니다.

[[image @///image/en5400.png center 480px]]

The wizard will guide you through a series of steps involved in creating a new application:
마법사는 새로운 어플리케이션을 생성할때 여러 단계를 거쳐서 안내할 것입니다:

- Chose a name for the application
- Configure the application and choose required plugins
- Build required models (it will create CRUD pages for each model)
- Allow you to edit the views of those pages using MARKMIN syntax
- 어플리케이션 이름 정하기
- 설정하고 필요한 플러그인을 선택
- 필요한 모델을 빌드하기(각 모델에 대한 CRUD를 생성할 것입니다.)
- MARKMIN 구문을 이용해서 이런 페이지들의 view를 수정할수 있게 해줍니다.


The image below shows the second step of the process.
아래 이미지는 두번째 단계를 보여줍니다.

[[image @///image/en5500.png center 480px]]

You can see a dropdown to select a layout plugin (from ``web2py.com/layouts``), a multiple choice dropdown to check other plugins (from ``web2py.com/plugins``) and a "login config" field where to put the Janrain "domain:key".
드랍다운에서 레이아웃 플러그인(``web2py.com/layouts``)을 선택할 수 있고, 다른 플러그인들(``web2py.com/plugins``)을 선택할 수 있습니다. 그리고 Janrain "domain:key"를 설정할 "login config" 필드도 선택할 수 있습니다.

The other steps are pretty much self-explanatory.
다른 과정은 따로 설명할 필요가 없을 정도로 직관적입니다.

The Wizard works well for what it does but it is considered an ''experimental feature'' for two reasons:
마법사는 자신에 역활을 잘 수행하기는 하지만 아직 두가지 이유에서 "실험적인 기능"임을 명심해야 합니다:

- Applications created with the wizard and edited manually, cannot later be modified by the wizard.
- The interface of the wizard will change over time to include support for more features and easier visual development.
- 마법사로 생성한 어플리케이션을 수동으로 수정한 경우 나중에 마법사에서는 수정할 수 없습니다.
- 마법사의 인터페이스는 시간이 지남에따라서 변할 것이고 더 많은 기능 지원과 더 쉬운 시각적인 개발을 위한 지원이 추가 될 것이기 때문입니다.

In any case the wizard is a handy tool for fast prototyping and it can be used to bootstrap a new application with an alternate layout and optional plugins.
어떤 경우이던지 마법사는 빠르게 프로토타이핑을 위한 편리한 툴이며 대체 레이아웃이나 선택적인 플러그인을 가지고 새로운 어플리케이션을 생성할때 사용될 수 있습니다.

#### Configuring **admin**, **admin** 설정하기

Normally there is no need to perform any configuration of admin but a few customizations are possible. After you login into admin you can edit the admin configuration file via the URL:
보통 admin을 설정할 필요는 없지만  몇가지 사용자 설정이 가능합니다. admin에 로긴한 후에 다음 URL을 통해서 설정 파일을 수정할 수 있습니다.
``
http://127.0.0.1:8000/admin/default/edit/admin/models/0.py
``
Notice that **admin** can be used to edit itself. In fact **admin** is an app as any other one.
**admin**은 자기 자신을 수정할 수 있으며 **admin**역시 하나의 어플리케이션입니다.

The file "0.py" is very much self documented and if you are opening probably you already know what you are looking for. Anyway few customizations exist that are more important than others:
"0.py" 파일은 파일 자체에 잘 문서화되어 있으면 이 파일은 연다는 것은 어떤것을 찾고 있는지 이미 잘 알고 있을 것입니다. 어쨌든 다른 것들과 달리 몇가지 사용자 설정이 존재합니다.

``
GAE_APPCFG = os.path.abspath(os.path.join('/usr/local/bin/appcfg.py'))
``
This should point to the location of the "appcfg.py" file that comes with the Google App Engine SDK. If you have the SDK you may want to change this config parameters to the correct value. It will allow you to deploy to GAE from the admin interface.
Google App Engine SDK에 포함된 "appcfg.py"파일의 위치를 나타냅니다.  SDK를 설치했다면 이 파라미터의 값을 그에 맞게 설정해야 할 것입니다. 이 값을 통해서 admin인터페이스에서 GAE로 배포할수 있게 해줍니다.

``DEMO_MODE``:inxx

You can also set web2py admin in demo mode:
web2py admin 을 데모 모드로 설정할 수 있습니다:
``
DEMO_MODE = True
FILTER_APPS = ['welcome']
``
And only the apps listed in filter apps will be accessible and they will be only accessible in read-only mode.
FILTER_APPS 리스트에 포함된 어플리케이션만이 접근 가능하고 읽기 모드서만 접근 가능합니다.

``MULTI_USER_MODE``:inxx
``virtual laboratory``:inxx

If you are a teacher and want to expose the administrative interface to students so that students can share one administrative interface for their projects (think of a virtual lab), can do it by setting:
당신이 선생님이고 학생에게 관리자 인터페이스를 제공하기를 원하고 학생들이 하나의 관리자 인터페이스를 그들의 프로젝트(가상의 연구실이라고 생각해봅니다)를 위해 공유할 수 있습니다. 다음과 같이 설정합니다:
``
MULTI_USER_MODE = True
``
In this way students will be required to login and will only be able to access their own apps via admin. You, as first user/teacher, will be able to access them all.
이런 방법으로 학생들은 로긴을 해야 하고 admin을 통해서 그들 각자의 어플리케이션에만 접근 가능할 것입니다. 첫사용자나 선생님의 경우에는 모든 어플리케이션에 접근 가능할 것입니다.

Mind that this mechanism still assumes all users are trusted. All the apps created under admin run under the same credentials on the same filesystem. It is possible for an app created by a student to access the data and the source of an app created by another student.
이런 매커니즘은 모든 사용자들이 신뢰할 수 있다고 가정하고 있다는 것을 염두해 두어야 합니다. admin하에서 생성된 모든 어플리케이션은 같은 파일 시스템에서 같은 신뢰관계에서 실행됩니다. 학생에 의해서 생성된 어플리케이션이 다른 학생이 생성한 어플리케이션의 데이타와 소스에 접근하는것이 가능합니다.

### More on **appadmin**, **appadmin** 더 알아보기

``appadmin``:inxx

**appadmin** is not intended to be exposed to the public. It is designed to help you by providing an easy access to the database. It consists of only two files: a controller "appadmin.py" and a view "appadmin.html" which are used by all actions in the controller.
**appadmin**은 외부에 노출되도록 의도된 것이 아닙니다. 데이터베이스에 쉽게 접근할 수 있는 기능을 제공하기 위해서 설계된 것입니다.  "appadmin.py" controller와 controller안의 모든 action에서 사용하는 "appadmin.html" view 파일 2개로 구성되어 있습니다.

The **appadmin** controller is relatively small and readable; it provides an example of designing a database interface.
**appadmin** controller는 상대적으로 작고 읽기 쉽습니다. 여기에서는 데이터페이스 인터페이스를 설계하는 예제가 제공됩니다.

**appadmin** shows which databases are available and which tables exist in each database. You can insert records and list all records for each table individually. **appadmin** paginates output 100 records at a time.
**appadmin**은 어떤 데이터베이스가 가용한지 각 데이터베이스에 어떤 테이블이 존재하는지 보여줍니다. 레코드를 삽입할 수 있고 각각의 테이블에 모든 레코드 목록을 출력할 수 있습니다. ""appadmin""은 한번에 100개의 레코드단위로 출력합니다.

Once a set of records is selected, the header of the pages changes, allowing you to update or delete the selected records.
하나의 레코드 단위가 select되면 페이지의 header가 변경되고 선택된 레코드를 갱신 삭제할 수 있습니다.

To update the records, enter an SQL assignment in the Query string field:
레코드를 갱신하기 위해서는 쿼리 스트링 필드에 SQL 대입문을 입력합니다:
``
title = 'test'
``:code

where string values must be enclosed in single quotes. Multiple fields can be separated by commas.
문자열의 경우는 작은 따옴표(')로 감싸야 합니다. 여러 필드의 경우 쉽표(,)로 구분할 수 있습니다.

To delete a record, click the corresponding checkbox to confirm that you are sure.
레코드를 삭제하는 경우 해당하는 체크박스를 선택합니다.

**appadmin** can also perform joins if the SQL FILTER contains a SQL condition that involves two or more tables. For example, try:
**appadmin**은 SQL FILTER에 2개 이상의 테이블이 연관된 SQL 조건문을 포함하고 있는 경우 join을 수행할 수 있습니다. 다음과 같이 확인해 보세요:
``
db.image.id == db.comment.image_id
``:code

web2py passes this along to the DAL, and it understands that the query links two tables; hence, both tables are selected with an INNER JOIN. Here is the output:
web2py는 이 것을 DAL에 전달하고 두 테이블의 쿼리 링크를 이해하고 INNER JOIN으로 두개의 테이블이 선택됩니다. 다음과 같이 출력됩니다.

[[image @///image/en5600.png center 480px]]

If you click on the number of an id field, you get an edit page for the record with the corresponding id.
id 필드의 수를 클릭하면  id에 해당하는 레코드를 편집할 수 있는 페이지를 볼 수 있습니다.

If you click on the number of a reference field, you get an edit page for the referenced record.
참조 필드의 수를 클릭하면 참조 필드에 대한 편집 페이지를 볼 수 있습니다.

You cannot update or delete rows selected by a join, because they involve records from multiple tables and this would be ambiguous.
join으로 선택된 row들은 갱신하고 삭제할 수 없습니다. 왜냐하면 이 레코드 들은 다수의 테이블에서 얻어진 것이고 어떤 테이블에 속하는지 모호하기 때문입니다.

In addition to its database administration capabilities, **appadmin** also enables you to view details about the contents of the application's ``cache`` (at ``/yourapp/appadmin/ccache``) as well as the contents of the current ``request``, ``response``, and ``session`` objects (at ``/yourapp/appadmin/state``).
데이터베이스 관리 기능에 덧붙여 **appadmin**은 어플리케이션의 ''cache''(''/yourapp/apamdin/ccache'')의 자세한 내용을 확인 할수도 있으면 ``request``, ``response``, ``session``(``/yourapp/appadmin/state``)객체에 현재 값 또한 확인 할 수 있습니다.

------
**appadmin** replaces ``response.menu`` with its own menu, which provides links to the application's **edit** page in **admin**, the **db** (database administration) page, the **state** page, and the **cache** page. If your application's layout does not generate a menu using ``response.menu``, then you will not see the **appadmin** menu. In that case, you can modify the appadmin.html file and add ``{{=MENU(response.menu)}}`` to display the menu.
**appadmin** 은 ``response.menu``를 자신의 메뉴로 변경합니다. 여기에는 어플리케이션 **admin**의 **edit** 페이지, **db** 페이지, **state** 페이지, **cache**페이지를 연결하는 링크를 제공합니다. 만약에 어플리케이션 레이아웃이 ``response.menu``를 이용해서 메뉴를 생성하지 않는 다면 **appadmin** 메뉴를 볼 수 없습니다. 이 경우 appadmin.html파일을 수정해서 ``{{=MENU(response.menu))}}``를 이용해서 메뉴를 표시할 수 있습니다.
------
